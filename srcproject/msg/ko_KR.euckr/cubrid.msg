
$
$ Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution. 
$
$   This program is free software; you can redistribute it and/or modify 
$   it under the terms of the GNU General Public License as published by 
$   the Free Software Foundation; either version 2 of the License, or
$   (at your option) any later version.
$
$  This program is distributed in the hope that it will be useful, 
$  but WITHOUT ANY WARRANTY; without even the implied warranty of 
$  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
$  GNU General Public License for more details. 
$
$  You should have received a copy of the GNU General Public License 
$  along with this program; if not, write to the Free Software 
$  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
$

$
$ $Id$
$
$ cubrid.msg
$

$set 1 MSGCAT_SET_GENERAL
1 \n%s\n\n
2 Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.\n
3 저작권 정보\n
5 '%s'은(는) integer 인자 값이 아닙니다.
6 '%s'은(는) floating 인자 값이 아닙니다.
7 인자 '%s' 이(가) 없습니다.
8 인자 '%s' 이(가) 중복되어 있습니다.
9 인자 '%s' 를(을) 위한 값이 없습니다.
10 '%s' 는(은) 알 수 없는 인자입니다.
11 인자 '%s' 는(은) 잘못된 위치에 지정되었습니다.
12 인자가 정의되어 있지 않습니다. 
13 인자 파싱을 위한 메모리를 할당할 수 없습니다.
14 인자의 길이가 최대 허용 값 %s을 초과 했습니다.
15 인자 파싱을 위한 목록 안에 메시지 번호 %d 이(가) 잘못 되었습니다.
16 [옵션]
17 옵션:

$set 4 MSGCAT_SET_PARAMETER
2 %s 은(는) 디렉터리가 아닙니다. 현재 디렉터리에 %s 을(를) 생성합니다.
3 %s 을(를) 열 수 없습니다. 설정 파일은 생성되지 않았습니다.
4 라인 %d 을(를) 설정 파일 %s에 쓸 수 없습니다.
6 시스템 설정 파일 "%s" 을(를) 액세스 할 수 없습니다: %s
7 HOME 환경 변수가 설정되지 않았습니다.
8 필요한 인자 "%s"의 값이 지정되지 않았습니다.
9 설정 파일 "%s" 을(를) 열 수 없습니다: %s
10 startup 파일 %2$s의 %1$d 라인:
11 환경 변수 %s:
12 알 수 없는 키워드입니다.
13 값의 타입이 인자의 타입과 일치하지 않습니다.
14 값을 저장하기 위한 메모리를 할당할 수 없습니다.
15 문자열의 끝을 알 수 없습니다.
16 값이 범위를 넘었습니다.
17 UNIX 에러: %s
18 해당되는 메시지가 없습니다.
19 값이 범위를 넘었습니다. 기본 설정 값으로 재설정합니다.
20 키워드 = '%s'    값 = %d    기본 설정 값 = %d\n
21 키워드 = '%s'    값 = %f    기본 설정 값 = %f\n

$set 5 MSGCAT_SET_ERROR
1 에러 코드 %1$d에 대한 메시지가 없습니다.
2 내부시스템 에러: 더 이상 자세한 정보가 없습니다.
3 가상메모리 할당 에러: %1$d 바이트의 메모리를 할당할 수 없습니다.
4 인터럽트 됨.
5 키 = "%1$s" 은(는) 해쉬 테이블 "%2$s" 내에 존재하지 않습니다.
6 해쉬 테이블 함수에 NULL 해쉬 테이블이 제공되었습니다. 
7 잘못된 페이지 수 %2$d로 디스크 볼륨 "%1$s"을(를) 포맷하려고 합니다.
8 %2$d 페이지 (%3$d 바이트)로 디스크 볼륨 "%1$s"을(를) 포맷할 수 없습니다.
9 %2$d 페이지 (%3$d K바이트)로 디스크 볼륨 "%1$s"을(를) 포맷하기에는 스페이스가 부족합니다. 현재 이용 가능한 스페이스는 %4$d 페이지 (%5$d K바이트) 입니다.
10 "%1$s" 디스크 볼륨을 마운트할 수 없습니다.
11 "%1$s" 디스크 볼륨을 마운트할 수 없습니다. 이 디스크 볼륨이 속한 데이터베이스 "%2$s"은(는) 사용자 %3$s(프로세스 ID:%4$d, 호스트 %5$s)이(가) %6$s 부터 사용하고 있습니다.
12 볼륨 "%1$s"을(를) 언마운트하는데 문제가 있습니다.
13 볼륨 "%2$s"의 %1$d 페이지를 읽는 도중에 I/O 에러 발생.
14 볼륨 "%2$s"의 %1$d 페이지를 쓰는 도중에 I/O 에러 발생.
15 디바이스의 스페이스가 부족하여 볼륨 "%2$s"의 %1$d 페이지를 쓸 수 없습니다.
16 "%1$s" 에서 "%2$s"으로 디스크 볼륨의 이름을 바꿀 수 없습니다.
17 내부 에러: 이미 해제된 볼륨 "%2$s"의 %1$d 페이지에 대한 읽기 시도. 
18 모든 페이지 버퍼가 fix 되었습니다.
19 내부 에러: pageptr = %1$p of page %2$d of volume "%3$s" is not fixed.
20 내부 에러: unknown pageptr = %1$p.
21 내부 에러: unknown sector %1$d of volume "%2$s".
22 내부 에러: unknown page %1$d of volume "%2$s".
23 내부 에러: trying to deallocate disk system page %1$d of volume "%2$s".
24 "%1$s" 볼륨에 스페이스가 부족합니다. 총 페이지 수 = %2$d, 여유 페이지 수 = %3$d.
25 데이터 볼륨에 스페이스가 부족합니다. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
26 인덱스 볼륨에 스페이스가 부족합니다. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
27 generic 볼륨에 스페이스가 부족합니다. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
28 temp 볼륨에 스페이스가 부족합니다. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
29 알림: "%1$s" 볼륨 스페이스 부족. 총 페이지 수 = %2$d, 여유 페이지 수 = %3$d.
30 알림: 데이터 볼륨 스페이스 부족. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
31 알림: 인덱스 볼륨 스페이스 부족. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
32 알림: generic 볼륨 스페이스 부족. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d. 
33 알림: temp 볼륨 스페이스 부족. 총 페이지 수 = %1$d, 여유 페이지 수 = %2$d.
34 내부 에러: %1$d nthpage is out of range for file %2$d in volume "%3$s". Current number of pages are %4$d.
35 내부 에러: Unknown volume identifier %1$d.
36 데이터베이스 용량이 디스크 용량을 초과했습니다. 요구 페이지 = %1$d.
37 "%1$s" 볼륨이 디스크 용량을 초과했습니다. 요구 페이지 = %2$d.
38 내부 에러: Unknown file VFID %1$d|%2$d.
39 내부 에러: Page %1$d|%2$d(volume "%3$s") of file VFID %4$d|%5$d(volume "%6$s") is invalid/deallocated according to allocation map.
40 내부 에러: %1$d expected pages, %2$d found pages for file VFID %3$d|%4$d(volume "%5$s").
41 내부 에러: Page %1$d|%2$d(volume "%3$s") is not part of file VFID %4$d|%5$d(volume "%6$s").
42 Cannot reorder anchored records on page %1$d of volume "%2$s".
43 내부 에러: incorrect number (%1$d) of slots passed for reordering records on page %2$d of volume "%3$s". There are actually %4$d slots.
44 "%2$s" 볼륨의 %1$d 페이지에 사용할 수 있는 스페이스가 없습니다.
45 "%3$s" 볼륨의 %2$d 페이지의 %1$d 슬롯은 anchored record로 할당되었습니다.  이 위치에 새로운 레코드를 삽입할 수 없습니다. 
46 내부 에러: slot %1$d on page %2$d of volume "%3$s" is not allocated.
47 "%1$s" 볼륨 내에 heap 파일을 생성할 수 없습니다.
48 삭제된 오브젝트(%1$d|%2$d|%3$d) 액세스
49 내부 에러: class of object %1$d|%2$d|%3$d is unknown.
50 내부 에러: relocation record of object %1$d|%2$d|%3$d may be corrupted.
51 내부 에러: object %1$d|%2$d|%3$d may be corrupted.
52 내부 에러: object overflow address %1$d|%2$d|%3$d may be corrupted.
53 오브젝트의 OID가 주어졌을 때 오브젝트 %1$d|%2$d|%3$d 을(를) 가지고 옵니다.
54 내부 에러: trying to manipulate an object of %1$d pages long. The maximum size allowed for an object is %2$d pages.
55 내부 에러: A page cycle reference was detected on page %1$d|%2$d of heap file %3$d|%4$d|%5$d.
56 내부 에러: unknown extendible hashing file (Volid: %1$d Fileid: %2$d) page (Volid: %3$d Pageid: %4$d) was specified.
57 키가 extendible hash table 내에 존재하지 않습니다.
58 문자열 "%1$s" 은(는) slotted page에서 처리하기에는 너무 깁니다.
59 내부 에러: the specified key type %1$d is not valid for the extendible hashing structure.
60 내부 에러: the extendible hashing structure has been corrupted.
61 내부 에러: the directory root page of the extendible hashing structure (Volid: %1$d Fileid: %2$d Pageid: %3$d) has been corrupted.
62 내부 에러: sorting record %1$d (size %2$d) does not fit in a page; the maximum allowable size is %3$d.
63 내부 에러: a temporary page was corrupted during sorting.
64 "%1$s"은(는) 알 수 없는 클래스입니다.
65 클래스 "%1$s" 이(가) 이미 존재합니다.
66 내부 에러: unknown force operation %1$d for object %2$d|%3$d|%4$d.
67 내부 에러: a heap file has not been allocated to store object %1$d|%2$d|%3$d.
68 내부 에러: different classnames for class with oid = %1$d|%2$d|%3$d were found. Found classnames are "%4$s", "%5$s" using classname hash table and heap, respectively.
69 내부 에러: different class object identifiers were found for class with name "%1$s". Found OIDS are %2$d|%3$d|%4$d, %5$d|%6$d|%7$d using classname hash table and heap, respectively.
70 내부 에러: Class with name "%1$s" and oid = %2$d|%3$d|%4$d does not exist in classname hash table.
71 내부 에러: Class with name "%1$s" and oid = %2$d|%3$d|%4$d does not exist in its heap.
72 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) 시스템에 의해 취소되었습니다.
73 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) %6$d|%7$d|%8$d 오브젝트에 대한 %5$s 락 대기 중에 타임아웃 되었습니다. 사용자 %9$s 이(가) 종료할 때까지 기다리고 있었습니다. 
74 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) %6$s 클래스에 대한 %5$s 락 대기 중에 타임아웃 되었습니다. 사용자 %7$s 이(가) 종료할 때까지 기다리고 있었습니다.
75 트랜잭션이(인덱스  %1$d, %2$s@%3$s|%4$d) %9$s 클래스의 %6$d|%7$d|%8$d 인스턴스에 대한 %5$s 락 대기 중에 타임아웃 되었습니다. 사용자 %10$s 이(가) 종료할 때까지 기다리고 있었습니다.
76 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) %6$d|%7$d 페이지에 대한 %5$s 락 대기 중에 타임아웃 되었습니다. 사용자 %8$s 이(가) 페이지 락을 해제할 때까지 기다리고 있었습니다.
77 내부에러: all buffers are fixed.
78 내부에러: an I/O error occurred while reading logical log page %1$d (physical page %2$d) of "%3$s".
79 내부에러: an I/O error occurred while writing logical log page %1$d (physical page %2$d) of "%3$s".
80 "%3$s"의 logical log page %1$d (physical page %2$d) 쓰는 도중 시스템 디바이스의 공간이 부족합니다. %4$d 바이트 이상은 쓸 수 없습니다. 
81 내부에러: logical log page %1$d may be corrupted.
82 로그 디스크 볼륨/파일 "%1$s"을(를) 마운트할 수 없습니다.  
83 경로 "%1$s"의 길이와 로그 prefix "%2$s"의 길이를 더한 것이 %3$d 보다 작아야 합니다.
84 로그 prefix "%1$s"의 길이가 너무 깁니다. %2$d 보다 작아야 합니다.
85 prefix "%1$s"이(가) 로그 디스크 상의 "%2$s"와 같지 않습니다. 로그가 데이터베이스 영역 밖에서 재 명명된 것 같습니다.
86 데이터베이스 "%1$s"은(는) release "%2$s"와 호환되지 않습니다.
87 복구 작업은 release "%3$s" 대신 "%1$s" release "%2$s"을(를) 사용하여 복구되어야 합니다. 복구 후, 데이터베이스는 릴리즈 "%4$s" 상에서 실행될 수 있습니다.
88 내부에러: release 문자열 "%1$s"은(는) %2$d 보다 깁니다. 헤더 로그를 바꿔야 합니다.
89 로그 "%1$s"는 주어진 데이터베이스에 속하지 않습니다.
90 redo logging은 페이지 수준 logging 오퍼레이션입니다. 데이터 페이지 포인터가 어드레스 일부분으로 주어져야 합니다.
91 postpone logging은 페이지 수준 logging 오퍼레이션입니다. 데이터 페이지 포인터가 어드레스 일부분으로 주어져야 합니다.
92 compensate logging은 페이지 수준 logging 오퍼레이션입니다. 데이터 페이지 포인터가 어드레스 일부분으로 주어져야 합니다.
93 경고: redo logging is ignored during redo recovery and normal rollbacks.
94 경고: postpone logging is ignored during redo recovery and normal rollbacks.
95 경고: undo logging is ignored during recovery and normal rollback.
96 "%1$s" 볼륨에 대해 media recovery가 필요합니다.
97 내부 에러: unable to find log page %1$d in log archives.
98 %2$d에서 %3$d까지의 페이지들을 archive하기 위한 archive 로그 "%1$s"를 생성할 수 없습니다.
99 백업 디렉터리 정보 파일 "%1$s" 을(를) 생성할 수 없습니다.
100 데이터베이스 "%1$s"를 백업할 수 없습니다.
101 알 수 없는 사용자 파일 "%1$s" 입니다.
102 파일 "%1$s" 은(는) 충분한 엔트리들을 가지고 있지 않습니다: %2$d 엔트리들이 예상됩니다.
103 파일 "%1$s" 은(는) 순서 없는 엔트리들을 갖고 있는 것 같습니다. 엔트리 %2$d (값:%3$d  %4$s  %5$s 들을 가진) 이(가) 발견 되었습니다. 값 %6$d %7$s 들을 가진 엔트리가 예상됩니다.
104 파일 "%1$s" 은(는) 데이터베이스(메인 볼륨)에 부정확한 엔트리를 갖고 있는 것 같습니다. 엔트리 %2$d (값 %3$d %4$s %5$s 들을 가진) 가(이) 발견되었습니다. 값 %6$d %7$s %8$s 들을 가진 엔트리가 예상됩니다.
105 백업 파일 "%1$s" 을(를) 액세스할 수 없습니다. 복구 또는 백업은 취소되었습니다.
106 트랜잭션 식별자가 다른 트랜잭션에서 이용되고 있기 때문에, 글로벌 트랜잭션 식별자 %1$d을(를) 가진 현재 트랜잭션을 커밋할 수 없습니다.
107 트랜잭션 식별자 %1$d 와(과) 연관된 전역 분산 트랜잭션이 없습니다.
108 현재의 트랜잭션 %1$d 은(는) 전역 식별자 %2$d 으로 분산 트랜잭션에 참여하기 이전에 커밋 또는 철회되어야 합니다. 
109 트랜잭션 %1$d 은(는) 리모트 사이트가 다운되었거나 트랜잭션이 취소되었기 때문에 시스템에 의하여 취소되었습니다. 
110 Isolation 레벨 값은 %1$d 와(과) %2$d 사이가 되어야 합니다.
111 당신의 트랜잭션은 서버 failure 혹은 모드 변경으로 인해 취소되었습니다.
112 호스트 "%1$s" 은(는) 한글 CUBRID를 수행할 수 있는 권한이 없습니다.
113 한글 CUBRID 서버를 재수행/초기화할 수 없습니다.
114 "%1$s"을 데이터베이스로 인식할 수 없습니다. 데이터베이스 볼륨/파일들은 외부에서 rename/copy 되었습니다. 
115 데이터베이스 "%1$s" 이(가) 이미 존재합니다.
116 데이터베이스 "%1$s" 이(가) 없거나, 파일 "databases.txt"를 액세스할 수 없습니다.
117 데이터베이스에 대한 절대 경로가 너무 깁니다. 경로 "%1$s"와 이름 "%2$s"을(를) 합한 길이는 %3$d 으로, 이는 %4$d 보다 작아야 합니다.
118 현재 작업 디렉터리를 정할 수 없습니다.
119 로컬 호스트 이름을 찾을 수 없습니다.
120 볼륨의 최대 개수(%1$d)를 초과했습니다.
121 데이터베이스의 영구 볼륨 "%1$s"을(를) 제거하려고 합니다.
122 시스템 메시지 카탈로그를 사용할 수 없습니다. 
123 데이터베이스 "%2$s"의 "%1$s"을(를) 생성할 수 없습니다.
124 볼륨 "%1$s"이(가) 이미 존재합니다.
125 %2$d 페이지의 generic 볼륨 "%1$s"이 자동 생성되어 확장되었습니다. 
126 라인 %2$d 상의 볼륨 용도 "%1$s"은 허용되지 않습니다.
127 라인 %2$d 상의 페이지 수 %1$d은(는) 유효하지 않습니다. 
128 페이지 수가 라인 %1$d에 주어지지 않았습니다. 
129 정의되지 않은 토큰 "%1$s"이(가) 라인 %2$d 상에 존재합니다.
130 가상 메모리 초과.
131 데이터베이스 시스템 에러.
132 현재 버전에서는 구현되어 있지 않습니다: %1$s.
133 Nested set 상수가 허용되지 않습니다.
134 단일 UPDATE문에서 클래스 애트리뷰트와 비 클래스 애트리뷰트를 혼용할 수 없습니다.
135 OID 컬럼에 대한 부적합한 문장입니다: %1$s.
136 "%1$s"은(는) 구현되지 않은 기능입니다.
137 손상된 authorization 오브젝트 입니다.
138 권한 클래스 "%1$s" 을(를) 찾을 수 없습니다.
139 클래스 "%1$s"의 권한 애트리뷰트 "%2$s" 액세스 시에 에러가 발생하였습니다.
140 오퍼레이션 "%1$s"은(는) DBA 또는 DBA 그룹의 멤버에 의해서만 수행될 수 있습니다.
141 "%2$s"의 멤버로 "%1$s"을(를) 추가할 수 없습니다.
142 사용자 계층 구조를 순환 그래프화 하므로 멤버를 추가할 수 없습니다. 
143 소유자가 없는 클래스가 발생하였습니다.
144 사용자 오브젝트를 액세스할 수 없습니다.
145 자기 자신에 대해 GRANT/REVOKE 명령할 수 없습니다. 
146 클래스 소유자에 대해 GRANT/REVOKE 명령할 수 없습니다.
147 GRANT 옵션이 없습니다.
148 권한 부여 오브젝트에 대해 쓰기 락을 얻을 수 없습니다.
149 권한 부여 오브젝트의 인스턴스를 생성할 수 없습니다.
150 자기 자신의 권한은 해제할 수 없습니다.
151 클래스 소유자의 권한은 해제할 수 없습니다.
152 GRANT가 없습니다.
153 데이터베이스에 대한 권한 부여 권리가 없습니다. 
154 불완전한 권한 부여 설정 - 데이터베이스에 대한 권한 부여 권리가 없습니다. 
155 권한 부여 클래스가 여러 개 발견되었습니다.
156 권한 부여 실패.
157 SELECT 권한 부여 실패. 
158 ALTER 권한 부여 실패. 
159 UPDATE 권한 부여 실패.
160 INSERT 권한 부여 실패.
161 DELETE 권한 부여 실패.
162 INDEX 권한 부여 실패.
163 EXECUTE 권한 부여 실패.
164 사용자 "%1$s" 이(가) 이미 존재합니다.
165 사용자 "%1$s" 을(를) 확인하십시오.
166 유효하지 않은 사용자가 지정되었습니다.
167 클래스 소유자만이 오퍼레이션을 수행할 수 있습니다.
168 멤버를 찾을 수 없습니다.
169 데이터베이스에서 사용자를 제거할 수 없습니다.
170 로그인된 사용자가 없습니다.
171 패스워드를 확인하십시오.
172 패스워드는 31 문자 이하여야 합니다.
173 데이터베이스 파일 "%1$s"을(를) 찾을 수 없습니다.
174 데이터베이스 파일 "%1$s"에 대한 쓰기 권한을 얻을 수 없습니다.
175 데이터베이스 파일 "%1$s"의 포맷이 잘못되어 있습니다.
176 date 포맷 변환 에러.
177 내부 스토리지에 large object를 생성할 수 없습니다.
178 MOP 없는 임시 OID가 발견되었습니다.
179 도메인 "%1$s" 은(는) 도메인 "%2$s"와 호환되지 않습니다.
180 주어진 값의 도메인 "%1$s"은(는) 대상 도메인 "%2$s"와(과) 호환되지 않습니다.
181 값을 도메인 "%1$s"에서 도메인 "%2$s"으로 변환 할 수 없습니다.
182 오버플로우 없이 도메인 "%1$s"에서 도메인 "%2$s"으로 변환할 수 없습니다.
183 예상치 않은 양의 데이터 수신; %1$d 을(를) 예상하였으나, %2$d을(를) 수신했습니다.
184 통신 버퍼를 할당할 수 없습니다.
185 클라이언트로부터의 데이터 수신 에러.
186 서버로부터의 데이터 수신 에러.
187 통신 버퍼가 사용되지 않았습니다.
188 알 수 없는 데이터베이스 "%1$s"입니다.
189 잘못된 호스트 이름 "%1$s".
190 서버 호스트를 찾을 수 없습니다.
191 "%2$s" 상의 서버 "%1$s"에 접속할 수 없습니다.
192 네트워크 구성 파일을 로드할 수 없습니다. 
193 서버가 클라이언트로부터 시스템 종료 명령을 받았습니다.
194 정의되지 않은 서버 요청 id %1$d 
195 서버 통신 에러: %1$s.
196 서버 이름이 정의되지 않았습니다.
197 마스터 서버와 연결할 수 없습니다.
198 수신 버퍼가 작아서, 데이터가 단절되었습니다.
199 서버가 응답하지 않습니다.
200 Not properly removing set from object after free.
201 잘못된 UNIQUE 테이블 엔트리가 제거되었습니다.
202 애트리뷰트 "%1$s"을 찾을 수 없습니다.
203 애트리뷰트 "%1$s"의 값은 "%3$s" 타입이 아닌 "%2$s" 타입이어야 합니다. 
204 인자가 없거나 유효하지 않은 인자로 함수를 호출하였습니다.
205 애트리뷰트 "%1$s"은(는) NULL이 될 수 없습니다.
206 애트리뷰트 "%1$s"은(는) UNIQUE 제약성을 가지고 있지 않습니다.
207 클래스 "%1$s"은(는) 크기가 0인 오브젝트를 갖고 있습니다.
208 메소드 "%1$s"을(를) 찾을 수 없습니다.
209 "%1$s"라는 이름을 가진 애트리뷰트나 메소드는 없습니다.
210 내부 에러: processing object template.
211 오브젝트 템플릿을 만드는 도중에 애트리뷰트가 삭제되었습니다.
212 애트리뷰트 "%1$s"은(는) UNIQUE 제약성에 위배 됩니다.
213 잘못된 UNIQUE 테이블 엔트리가 발견되었습니다.
214 도메인 충돌이 애트리뷰트 "%1$s" 상에 존재합니다.
215 id %1$d 을(를) 가진 애트리뷰트가 없습니다.
216 값에 대해 잘못된 오브젝트 소유권한을 갖는 tag.
217 오퍼레이션은 오직 클래스 오브젝트에 대해서 수행될 수 있습니다.
218 db_get path expression에 유효하지 않은 오브젝트가 존재합니다.
219 유효하지 않은 db_get path expression.
220 db_get path expression에 유효하지 않은 set이 존재합니다.
221 db_get path expression에 유효하지 않은 set 인덱스가 존재합니다.
222 %2$d 보다 큰 문자열을 "%1$s" 애트리뷰트에 할당하려고 합니다.
223 %2$d 값이 smallint 애트리뷰트 "%1$s"에 비해 너무 큽니다.
224 데이터베이스가 다시 시작되지 않았습니다.
225 NOT NULL 제약성을 가진 애트리뷰트 "%1$s"에 값이 없습니다.
226 클래스에 비어 있는 컴포넌트 리스트가 있습니다.
227 애트리뷰트 "%1$s"에 값을 여러 번 할당하려고 합니다.
228 %2$d 개의 인자로 메소드 "%1$s"을(를) 호출하려고 합니다. 최대 %3$d 개의 인자까지 허용됩니다.
229 메소드 "%1$s"의 %2$d 번째 인자는 도메인 "%3$s" 입니다. 주어진 값의 도메인 "%4$s"이 잘못되었습니다.
230 애트리뷰트 "%1$s"은(는) 문자열 길이 %2$d을(를) 초과할 수 없습니다. 최대 허용 문자열 길이는 %3$d 입니다.
231 임시 오브젝트에 대해 유효하지 않은 API 오퍼레이션이 시도되었습니다.
232 오브젝트 템플릿을 여러 트랜잭션에 걸쳐 사용해서는 안됩니다.
233 기본 타입 이름 "%1$s"으로 클래스를 생성할 수 없습니다.
234 메소드 파일 "%1$s"이(가) 없습니다. 
235 %1$d 개의 resolve할 수 없는 메소드 함수가 있습니다.
236 resolve할 수 없는 메소드 "%1$s"입니다.
237 동적 링크 도중에 치명적인 문제가 발생하였습니다.
238 메소드 파일 "%1$s"을(를) 액세스할 수 없습니다.
239 애트리뷰트 "%1$s"을(를) 찾을 수 없습니다.
240 메소드 "%1$s"을(를) 찾을 수 없습니다. 
241 이름 "%1$s"을 가지는 애트리뷰트나 메소드는 없습니다.
242 메소드 "%1$s"에 대한 signature %2$s를 찾을 수 없습니다.
243 메소드 "%1$s"의 $2%d 번째 인자가 정의되지 않았습니다.
244 도메인 이름 "%1$s"은(는) 클래스 이름이나 기본 타입이 아닙니다.
245 "%1$s"은(는) 애트리뷰트 이름으로 사용되고 있습니다.
246 "%1$s"은(는) 메소드 이름으로 사용되고 있습니다.
247 스키마 관리자 내부 함수에 잘못된 인자 발생.
248 애트리뷰트 도메인 "%1$s"은(는) UNIQUE 제약 조건 사용에 적합하지 않습니다.
249 클래스 "%1$s"에 주어진 오퍼레이션은 인스턴스를 생성하기 전에만 수행될 수 있습니다. 
250 shared 값이 정의된 애트리뷰트 "%1$s"에 인덱스를 생성할 수 없습니다.
251 메소드 "%1$s"에 signature %2$s이(가) 이미 존재합니다.
252 해당 오퍼레이션을 위해서는 애트리뷰트 "%1$s"이 set 도메인을 가져야만 합니다.
253 애트리뷰트 "%1$s"을(를) nested set 도메인으로 정의할 수 없습니다.
254 애트리뷰트 "%1$s"의 도메인 "%2$s"을(를) 제거할 수 없습니다.
255 애트리뷰트 "%1$s"은(는) 가변 길이 도메인이 아닙니다.
256 슈퍼 클래스가 이미 존재합니다.
257 슈퍼 클래스 추가는 클래스 계층의 순환 현상을 야기시킵니다.
258 슈퍼 클래스가 없습니다. 
259 메소드 "%1$s"에 다중 signature가 존재합니다.
260 메소드 "%1$s"의 %2$d 번째 인자는 set 도메인이 아닙니다.
261 "%1$s"에 대한 resolution을 찾을 수 없습니다.
262 주어진 값의 도메인 "%2$s"은(는) 애트리뷰트 "%1$s"에 적합하지 않습니다.
263 스키마 관리자가 내부적으로 손상되었습니다.
264 애트리뷰트/메소드 "%1$s"에 대한 alias "%2$s"은 유일하지 않습니다.
265 conflicting 도메인 "%2$s"을(를) 가지는 Shadowing 애트리뷰트 "%1$s"입니다.
266 클래스 "%2$s"와 "%3$s"간에 애트리뷰트 이름 "%1$s"이(가) 충돌됩니다.
267 conflicting signature를 가지는 shadowing method "%1$s"입니다.
268 클래스 "%2$s"와 "%3$s"간에 메소드 이름 "%1$s"이(가) 충돌됩니다.
269 도메인 "%1$s"에 인덱스를 생성할 수 없습니다.
270 도메인 "%1$s"에 UNIQUE 제약 조건을 정의할 수 없습니다.
271 클래스 계층의 순환 현상 검출; "%1$s"은(는) "%2$s"의 슈퍼 클래스입니다.
272 클래스 "%2$s"에 인덱스 "%1$s"가 이미 존재합니다.
273 인덱스 "%1$s"이 존재하지 않습니다.
274 이름에 유효하지 않은 문자가 사용되었습니다: "%1$s".
275 애트리뷰트 "%1$s"에 잘못된 오퍼레이션입니다. 클래스 "%2$s"(으)로부터 상속되었습니다.
276 메소드 "%1$s"에 잘못된 오퍼레이션입니다. 클래스 "%2$s"(으)로부터 상속되었습니다.
277 "%1$s"에 잘못된 오퍼레이션입니다. 클래스 "%2$s"(으)로부터 상속되었습니다.
278 클래스 "%4$s"은(는) "%1$s"에 대한 호환되지 않는 도메인을 가집니다. 이들은 클래스 "%2$s"와 "%3$s"(으)로부터 상속되었습니다.
279 클래스 "%4$s"에서 클래스 "%2$s"(으)로부터 상속된 "%1$s"은(는) 주어진 데로 처리될 수 없습니다. 클래스 "%3$s"(으)로부터의 정의가 더 상세합니다.
280 클래스 "%3$s"에 호환성 없는 도메인을 가진 로컬 정의가 존재하기 때문에 "%1$s"은(는) 클래스 "%2$s"(으)로부터 상속될 수 없습니다.
281 클래스 "%3$s"의 클래스 "%2$s"(으)로부터 상속된 "%1$s"은(는) alias되었지만, 다른 source로부터의 substitute는 존재하지 않습니다.
282 클래스 "%4$s"의 클래스 "%3$s"(으)로부터 상속된 "%1$s"은(는) 클래스 "%2$s"에 대한 alias substitute 역할을 할 수 없습니다. 도메인 호환성이 없습니다.
283 클래스 "%4$s"의 클래스 "%3$s"(으)로부터 상속된 "%1$s"은(는) 클래스 "%2$s"에 대한 alias substitute 역할을 할 수 없습니다. 정의된 도메인이 덜 상세합니다. 
284 클래스 내에서 정의되었으므로 "%1$s"에 대한 상속을 요청할 수 없습니다.
285 이미 같은 이름으로 정의된 것이 있으므로, 상속된 "%2$s"에 대한 alias로 "%1$s"를 사용할 수 없습니다.
286 "%3$s"의 "%2$s"에 대한 alias로 "%1$s"을(를) 사용할 수 없습니다. 같은 이름을 가진 컴포넌트가 이미 "%4$s"로부터 상속되었습니다. 
287 "%3$s"(으)로부터 상속된 메소드를 shadow시키므로, 클래스 "%1$s"에서 애트리뷰트 "%2$s"를 정의할 수 없습니다.
288 "%3$s"(으)로부터 상속된 애트리뷰트를 shadow시키므로, 클래스 "%1$s"에서 메소드 "%2$s"를 정의할 수 없습니다.
289 같은 이름의 애트리뷰트를 이미 가지고 있으므로, 서브클래스 "%1$s"은(는) 클래스 "%3$s"(으)로부터 메소드 "%2$s"을(를) 상속받을 수 없습니다.
290 같은 이름의 메소드를 이미 가지고 있으므로, 서브클래스 "%1$s"은(는) 클래스 "%3$s"(으)로부터 애트리뷰트 "%2$s"을(를) 상속받을 수 없습니다.
291 "%1$s"은(는) 클래스 "%2$s"에서는 애트리뷰트로, 클래스 "%3$s"에서는 메소드로 정의되어 있습니다. 
292 No populate specification with index "%1$s".
293 해당 오퍼레이션이 이 클래스 타입에서는 허용되지 않습니다.
294 정의되지 않은 환경 변수 "%1$s"이(가) 메소드 파일에서 참조되었습니다.
295 클래스"%1$s"을(를) 변경할 수 없습니다. 시스템 카탈로그에 스페이스가 없습니다. 스페이스를 얻기 위해 compactdb 유틸리티를 사용하시오.
296 잘못된 속성 리스트가 나타났습니다.
297 alias "%1$s"이(가) 여러 번 사용되었습니다.
298 클래스 "%1$s"에서 "%3$s"의 "%2$s"에 대한 resolution은 허용되지 않습니다.  해당 클래스는 슈퍼 클래스가 아닙니다.
299 "%1$s"은(는) 예약어이므로 애트리뷰트, 메소드 또는 클래스 이름으로 사용될 수 없습니다.
300 애트리뷰트 "%1$s"에 DEFAULT 값과 UNIQUE 제약 조건을 함께 정의할 수 없습니다.
301 애트리뷰트 "%1$s"에 길이 제약 조건(%2$d)을 정의할 수 없습니다. 최대 길이 제약은 %3$d 입니다.
302 set에 엘리먼트를 추가할 수 없습니다.
303 값이 set에 이미 존재합니다.
304 set 인덱스 %1$d이(가) 범위를 벗어났습니다.
305 sequence 인덱스 %1$d이(가) 범위를 벗어났습니다.
306 요청된 오퍼레이션의 대상은 sequence이어야 합니다.
307 요청된 오퍼레이션은 대상은 set이어야 합니다.
308 엘리먼트 값이 set의 도메인과 다릅니다.
309 잘못된 set 엘리먼트 인덱스(%1$d)가 주어졌습니다.
310 엘리먼트가 set에 없습니다.
311 엘리먼트가 sequence에 없습니다.
312 "%1$s"은(는) 잘못된 set 도메인입니다.
313 읽기도중 오브젝트 버퍼에서 언더플로우가 발생하였습니다.
314 쓰기도중 오브젝트 버퍼에서 오버플로우가 발생하였습니다.
315 부적합한 메타클래스 정의가 발생하였습니다.
316 변환자 크기 계산이 맞지 않습니다. %1$d을(를) 예상했으나 %2$d를 얻었습니다.
317 부적합한 디스크 표현이 클래스 "%1$s"에서 발견되었습니다.
318 오브젝트를 로딩하는 동안 sync가 맞지 않았습니다. 데이터베이스가 손상되었거나 이전 것일 수 있습니다. 
319 정의되지 않은 애트리뷰트 확장은 무시됩니다.
320 오브젝트에 대한 손상된 디스크 표현입니다.
321 workspace가 손상됐을 가능성이 있습니다.
322 workspace에서 MOP를 찾을 수 없습니다.
323 workspace에서 비임시 MOP를 upgrade하려고 해서는 안됩니다.
324 클래스가 없는 오브젝트가 workspace에서 발견되었습니다.
325 dirty 리스트 내의 MOP를 garbage-collection하려고 해서는 안됩니다.
326 workspace의 오브젝트의 클래스 포인터를 변경하려고 해서는 안됩니다.
327 NULL OID를 가진 MOP는 생성할 수 없습니다.
328 workspace에서 클래스가 없는 인스턴스가 발견되었습니다.
329 workspace에 오브젝트 리스트 링크가 할당되지 않았습니다.
330 workspace pin violation
331 가상 메모리가 부족합니다. OS로부터 workspace 블럭을 할당할 수 없습니다. 트랜잭션이 취소되었습니다.
332 원래 예상된 workspace 크기를 초과했습니다. 자동 확장되었습니다.
333 workspace 스토리지를 할당하는 동안 메모리가 부족합니다. 트랜잭션은 취소되었습니다.
334 %1$d 바이트 할당은 최대 workspace 블록 크기를 초과한 것입니다. max_block_size 인자를 조정 하십시오. 트랜잭션은 취소되었습니다.
335 workspace내에 할당되지 않은 오브젝트를 free하려는 시도는 무시됩니다.
336 한 번 이상 오브젝트를 free하려는 시도는 무시됩니다.
337 음수 크기를 갖는 오브젝트를 할당하려는 작업은 무시됩니다.
338 Map 엔트리 식별자 초과.
339 트랜잭션 %1$d의 소유가 아니므로 critical section을 종료할 수 없습니다. 
340 자식 프로세스를 fork할 수 없습니다. 
341 자식 프로세스를 exec할 수 없습니다.
342 프로세스 그룹을 변경할 수 없습니다.
343 Request_id는 이미 사용되고 있습니다.
344 %1$s.
345 master로부터 shutdown 메시지를 읽는 도중 에러 발생.
346 master로부터 stop shutdown 메시지를 읽는 도중 에러 발생.
347 master 서버와의 pipe를 생성할 수 없습니다.
348 service나 포트 번호를 명시해야 합니다.
349 알 수 없는 TCP 서비스 입니다: %1$s.
350 호스트 "%1$s"의 이름을 이용하여 호스트를 찾을 수 없습니다.
351 TCP socket을 생성할 수 없습니다.
352 tcp_open: 예약된 TCP 포트를 얻을 수 없습니다.
353 master 서버에 접속할 수 없습니다.
354 socket에 새로운 프로세스 소유자를 지정할 수 없습니다. 
355 socket 스트림을 생성할 수 없습니다.
356 UNIX 도메인 소켓을 위한 파일 '%1$s' (이)가 존재하지 않습니다.
357 로컬 어드레스를 바인드할 수 없습니다... 중지.
358 Accept 실패
359 데이타그램 bind 에러.
360 데이타그램 accept 에러.
361 데이타그램 connect 에러.
362 데이타그램 socket 에러.
363 master socket으로부터 recvmsg 실패
364 서버에 새로운 요구를 전송하고 있습니다.
365 클라이언트에 broadcast 메시지를 전송하고 있습니다.
366 서버 오류: %1$s
367 서버 %1$s은(는) 이미 존재합니다.
368 %1$s에 대한 연결 시도 중 통신 에러.
369 사용하지 않는 에러코드입니다.
370 사용하지 않는 에러코드입니다.
371 사용하지 않는 에러코드입니다.
372 사용하지 않는 에러코드입니다.
373 읽는 도중 예기치 않은 EOF입니다: %1$d.
374 %1$d 또는 %2$d을(를) 읽는 도중 예기치 않은 EOF입니다.
375 Conversion error on (0x%1$c%2$c) %3$d and %4$d converted to %5$d.
376 public 클래스가 없습니다.
377 에러 %1$d: 멀티미디어 계층 구조에 애트리뷰트 "%2$s" 추가 에러 
378 에러 %1$d: 멀티미디어 계층 구조에 "%3$s"로 구현된 메소드 "%2$s" 추가 에러 
379 에러 %1$d: 멀티미디어 계층 구조에 슈퍼 클래스 추가 에러
380 동적 로더가 이미 초기화되었습니다.
381 동적 로더가 초기화되지 않았습니다.
382 동적 로더가 비정상적으로 초기화되었습니다.
383 "%1$s"은(는) 오브젝트 파일 또는 아카이브 파일이 아닙니다.
384 "%1$s"에 대한 절대 경로를 결정할 수 없습니다.
385 ld 프로세스가 종료되었습니다. 종료 코드는 %1$d입니다.
386 signal %1$d에 의하여 ld 프로세스가 종료되었습니다.
387 ld 프로세스가 종료되었습니다. 알 수 없는 waitval 0x%1$lx입니다. 
388 "%1$s"의 초기 이미지를 액세스할 수 없습니다.
389 시스템 에러: %1$s.
390 Problem with "%1$s": %2$s.
391 다른 SIGPIPE 핸들러와의 충돌 발생.
392 동적 로더 daemon을 생성할 수 없습니다.
393 동적 로더 daemon이 사라졌습니다.
394 Range endpoint not between 0 and 256.
395 잘못된 subexpression이 명시되었습니다.
396 escape내에 범위를 벗어난 8진 숫자가 있습니다.
397 regular expression이 제대로 구분되지 않았습니다. 
398 expression이 컴파일되기 전에 텍스트 검색이 호출되었습니다.
399 regular expression의 괄호의 짝을 확인하십시오.
400 regular expression의 괄호가 너무 많이 중첩되어 있습니다.
401 두 개 이상의 숫자가 한 범위 내에 명시되어 있습니다.
402 '{' 의 짝을 확인하십시오.
403 범위 expression의 첫 번째 수가 두 번째 수보다 큽니다.
404 regular expression의 '[' 의 짝이 맞지 않습니다.
405 regular expression이 너무 길어서 컴파일할 수 없습니다.
406 잘못된 B+tree 인덱스 식별자: (vfid = (%1$d, %2$d), rt_pgid: %3$d).
407 알 수 없는 키 %1$s이(가) B+tree 인덱스에서 참조되었습니다. {vfid: (%2$d, %3$d), rt_pgid: %4$d, key_type: %5$s}.
408 알 수 없는 값(oid) %1$d|%2$d|%3$d이(가) 참조되었습니다.
409 중복된 값(oid) %1$d|%2$d|%3$d이(가) 참조되었습니다.
410 NULL 키가 언급되었습니다.
411 유효하지 않은 B+tree 인덱스 키 타입 "%1$s"입니다.
412 범위 검색 명세가 유효하지 않습니다.
413 알 수 없는 애트리뷰트 식별자: %1$d.
414 알 수 없는 클래스 식별자: %1$d|%2$d|%3$d.
415 유효하지 않은 클래스 식별자: %1$d|%2$d|%3$d.
416 알 수 없는 표시 식별자: %1$d.
417 유효하지 않은 표시 식별자: %1$d.
418 레코드 디스크립터를 위한 공간이 충분하지 않습니다: %1$d
419 클래스가 최대 representation 카운트에 도달했습니다: %1$d.
420 클래스 %1$d|%2$d|%3$d은(는) 이미 표현되었습니다.
421 클래스 카탈로그에 표시 디렉터리가 없습니다: %1$d|%2$d|%3$d.
422 클래스 카탈로그에 표시 정보가 없습니다. Repr_Id: %1$d|%2$d|%3$d  - %4$d.
423 유효하지 않은 세션입니다.
424 수행할 문장이 없습니다.
425 클래스 "%2$s"의 애트리뷰트 "%1$s"와(과) 호환되지 않는 데이터 타입입니다.
426 애트리뷰트 "%1$s"와(과) 호환되지 않는 데이터 타입입니다.
427 데이터 타입 "%1$s"에 대해 오버플로우가 발생했습니다.
428 수정할 수 없습니다.
429 알 수 없는 명령어입니다.
430 알 수 없는 변수 "%1$s"입니다.
431 SQL/X 인터프리터 또는 파서 에러
432 알 수 없는 클래스 "%1$s"입니다.
433 클래스 "%2$s"의 애트리뷰트 "%1$s"은(는) 알 수 없습니다.
434 질의로부터 정확한 컬럼 이름을 찾을 수 없습니다.
435 다중 문장은 허용되지 않습니다.
436 질의문이 아닙니다.
437 유효하지 않은 long object ID(%1$s,%2$d,%3$s,%4$s).
438 long object descriptor에 충돌이 발생하였습니다.
439 offset %1$d은(는) long object의 길이 %2$d보다 더 큽니다.
440 커서 위치가 유효하지 않습니다.
441 유효하지 않은 커서 오퍼레이션입니다.
442 알 수 없는 커서 위치입니다. 
443 튜플 값 인덱스 %1$d이(가) 범위를 벗어났습니다.
444 부정확한 애트리뷰트 이름: "%1$s".
445 값 리스트 인덱스 %1$d이(가) 범위를 벗어났습니다.
446 어플리케이션이 닫지 않고 트랜잭션 관리자가 닫은 질의 결과 스트럭쳐들이 있습니다.
447 이미 닫힌 질의 결과 스트럭쳐에 대해 오퍼레이션을 시도하고 있습니다.
448 튜플 크기는 현재 한 페이지보다 작게 제한되어 있습니다.
449 정의되지 않은 질의 식별자: %1$d.
450 유효하지 않은 set 연산자: %1$d.
451 인스턴스가 없는 heap 파일입니다.
452 XASL 트리 노드의 컨텐츠가 유효하지 않습니다.
453 더 이상 액세스할 명세 노드가 없습니다.
454 잘못된 데이터 타입을 참조하였습니다.
455 질의 파일 페이지가 더 이상 남아 있지 않습니다.
456 데이터 타입 참조가 호환성이 없습니다.
457 질의 결과 타입이 잘못되었습니다.
458 덧셈에서 오버플로우가 발생하였습니다.
459 질의 결과가 단일 튜플이 아닙니다.
460 호스트 변수가 적게 주어졌습니다.
461 결과 컬럼 보다 호스트 변수가 많이 주어졌습니다.
462 결과 값은 NULL입니다. 그러나, indicator 변수가 없습니다.
463 cursor 문이 prepare되지 않았습니다.
464 커서는 SELECT 문이어야 합니다.
465 커서가 아직 열리지 않았습니다.
466 커서를 다시 열기 전에 반드시 닫아야 합니다.
467 한 오브젝트로 결과가 리턴되어야 합니다.
468 EXECUTE IMMEDIATE 문에는 positional markers을 허용하지 않습니다.
469 잘못된 데이터 타입이 사용되었습니다.
470 질의를 최적화하기에는 아이템이 너무 많습니다.
471 파일 %2$s의 라인 %1$d에서 메모리를 모두 소모했습니다.
472 호스트 '%3$s'에서 로컬 데이터베이스 '%2$s'의 %1$s 커넥터가 다운되었습니다.
473 호스트 '%2$s'의 로컬 데이터베이스 '%1$s'(으)로부터의 보고: %3$s.
474 %2$s 도중 에러 %1$s이(가) 발생하였습니다.
475 인덱스 %1$s을(를) 가진 질의 명세가 없습니다.
476 LDB %1$s은(는) 이미 존재합니다. 
477 LDB %1$s를 액세스하기 위해 호스트 %2$s의 master와 접속할 수 없습니다.
478 로컬 데이터베이스 "%1$s"은(는) 등록된 LDB가 아닙니다.
479 현재 다른 클라이언트가 로컬 데이터베이스 "%1$s"을(를) 액세스하고 있으므로, LDB에 대한 변경/제거할 수 없습니다.
480 로컬 데이터베이스 "%1$s"이(가) 비어있지 않으므로 제거할 수 없습니다.
481 "%1$s"은(는) 프락시 가상 클래스가 아닙니다.
482 "%1$s"은(는) 가상 클래스가 아닙니다.
483 "%1$s"은(는) 클래스 "%2$s"의 애트리뷰트가 아닙니다.
484 프락시 가상 클래스 "%1$s"에 대한 object_id는 이미 설정되었습니다.
485 프락시 클래스 "%1$s"의 인스턴스의 하나 이상의 object_id 애트리뷰트의 값이 NULL입니다.
486 오브젝트는 수정 가능한 가상 클래스 인스턴스가 아닙니다.
487 오브젝트는 인스턴스가 아닙니다.
488 클래스의 애트리뷰트는 가상클래스 또는 프락시 가상 클래스가 될 수 없습니다. 
489 프락시 가상 클래스의 애트리뷰트는 클래스, 가상 클래스, 또는 오브젝트가 될 수 없습니다.
490 슈퍼 클래스 "%1$s"은(는) "%2$s"와(과) 같은 클래스 타입이어야 합니다.
491 프락시 질의 명세 "%1$s"(으)로부터 개체 이름을 추출할 수 없습니다.
492 %1$s
493 문법: %1$s %2$s
494 시멘틱: %1$s %2$s
495 실행: %1$s %2$s
496 정의되지 않은 키가 사용되었습니다.
497 알 수 없는 값(oid) %1$d|%2$d|%3$d이(가) 참조되었습니다.
498 중복 값 (oid) %1$d|%2$d|%3$d이(가) 참조되었습니다.
499 널 키가 참조되었습니다.
500 중복 키가 참조되었습니다.
501 유효하지 않은 트리거 우선순위 입니다.
502 트리거의 대상 클래스가 없습니다.
503 트리거 "%1$s"을(를) 찾을 수 없습니다.
504 내부 에러: 트리거 처리 도중 "%1$s".
505 트리거 이름 "%1$s"은(는) 이미 존재합니다.
506 "%1$s"은 가상 클래스이므로 트리거를 정의할 수 없습니다.
507 유효하지 않은 트리거 대상 클래스 "%1$s"입니다. 
508 유효하지 않은 트리거 대상 애트리뷰트 "%1$s"입니다. 
509 유효하지 않은 트리거 조건 "%1$s"입니다. 
510 유효하지 않은 트리거 액션 "%1$s"입니다. 
511 트리거 "%1$s"을(를) 액세스할 권한이 없습니다.
512 트리거 "%1$s"을(를) 삭제할 권한이 없습니다.
513 트리거 "%1$s"을(를) 갱신할 권한이 없습니다.
514 트리거 "%1$s"을(를) 변경할 권한이 없습니다.
515 트리거 액션 수행 시간 %2$s는 트리거 조건 수행 시간 %1$s보다 빠를 수 없습니다.
516 트리거 "%2$s"에서 최대 트리거 깊이 %1$d를 초과하였습니다.
517 트리거 "%1$s"으로 인해 오퍼레이션이 취소되었습니다.
518 내부 에러: 트리거 처리 도중 "%1$s".
519 유효하지 않은 트리거 조건 타입입니다.
520 REJECT 액션은 AFTER, DEFERRED 액션 시간에는 사용할 수 없습니다.
521 REJECT 액션은 ABORT, TIMEOUT 이벤트와는 함께 사용할 수 없습니다.
522 트리거 조건이 주어지지 않았습니다.
523 트리거 액션이 주어지지 않았습니다.
524 명시된 액티비티는 다른 사용자가 소유이므로 제거할 수 없습니다.
525 "%1$s"에 대한 조건 컴파일 에러: %2$s
526 "%1$s"에 대한 액션 컴파일 에러: %2$s
527 "%1$s"에 대한 조건 evaluating 에러: %2$s
528 "%1$s"에 대한 액션 evaluating 에러: %2$s
529 트랜잭션을 커밋할 수 없습니다. 트리거 "%1$s"에 의해 무효화되었습니다.
530 regular expression이 없습니다.
531 regular expression이 너무 길거나 복잡합니다.
532 regular expression에 괄호 또는 대괄호의 짝이 맞지 않습니다.
533 regular expression 내의 참조가 범위를 벗어났습니다.
534 regular expression에 잘못된 문자가 포함되었거나 문법이 틀렸습니다.
535 regular expression 검색을 위한 텍스트가 주어지지 않았습니다.
536 잘못된 opcode가 regular expression 내에 포함되어 있습니다.
537 regular expression 컴파일러에 잘못된 검색 명령 코드가 발생하였습니다.
538 regular expression 작업 버퍼를 초기화할 필요가 있습니다. 
539 0으로 나누려 합니다.
540 %1$s.
541 볼륨 %1$s"에 대한 free 페이지 수가 일치하지 않습니다. 볼륨 헤더에 의해 %2$d를, 비트맵에 의해 %3$d를 얻었습니다. 
542 용량 "%1$s"에 대한 free 섹터 수가 일치하지 않습니다. 볼륨 헤더에 의해 %2$d를, 비트맵에 의해 %3$d를 얻었습니다.
543 볼륨 "%1$s"에 대한 디스크 헤더가 불완전합니다.
544 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). B+tree key %6$s entry for object OID: %7$d|%8$d|%9$d was not found on B+tree: %10$d|%11$d|%12$d.
545 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). Key and OID: %6$d|%7$d|%8$d entry on B+tree: %9$d|%10$d|%11$d is incorrect. The object does not exist.
546 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). Expecting %6$d OID entry values, but %7$d were found on B+tree: %8$d|%9$d|%10$d.
547 서버 release %1$s은(는) 클라이언트 release %2$s와(과) 다릅니다.
548 프락시 클래스 "%1$s"에 object_id가 정의되지 않았습니다.
549 프락시 인스턴스를 찾을 수 없습니다.
550 알 수 없는 savepoint 이름 %1$s입니다.
551 볼륨 정보 경로 파일 "%1$s"을(를) 찾을 수 없습니다. 내부 테이블로부터 읽기를 계속합니다.
552 date 연산 언더플로우 발생.
553 time 연산 언더플로우 발생.
$ LOADDB 
554 로더는 잘못된 상태입니다. 더 이상 오퍼레이션이 불가능합니다.
555 데이터베이스 로딩 도중 메모리 할당 에러 발생.
556 값이 너무 많습니다. %d 개가 예상됩니다. 
557 %2$s의 애트리뷰트 %1$s에 대하여 타입 %3$s은(는) set의 도메인으로 허용되지 않습니다.
558 %2$s의 애트리뷰트 %1$s에 대하여 타입 %3$s을 예상하였으나 set 상수를 얻었습니다.
559 %2$s의 애트리뷰트 %1$s에 대하여 타입 %3$s을 예상하였으나 %4$s을(를) 얻었습니다.
560 %2$s의 애트리뷰트 %1$s에 대하여 도메인은 unqualified 오브젝트에 대한 참조를 제공하기에는 충분치 않습니다.
561 Nested set은 허용되지 않습니다.
562 시스템 클래스 %1$s을(를) 데이터베이스 로더를 통해 로드할 수 없습니다.
563 내부 클래스 %1$s에 대한 참조가 NULL로 변환되었습니다.
564 %2$s의 애트리뷰트 %1$s은(는) UNIQUE 제약 조건에 위배됩니다.
565 constructor 메소드 %1$s이(가) 클래스 %2$s에 정의되어 있지 않습니다.
566 사용하지 않는 에러코드입니다.
567 너무 많은 constructor 메소드 인자가 주어졌습니다. %1$d 개를 예상합니다.
568 constructor 메소드 인자가 부족합니다. %1$d 개를 예상했으나, %2$d 개가 주어졌습니다. 
569 애트리뷰트 값이 부족합니다. %1$d 개를 예상했으나, %2$d 개가 주어졌습니다.
570 GLO 데이터 파일 "%1$s"을(를) 액세스할 수 없습니다.
571 인스턴스는 이전에 forward reference를 통해 생성되었습니다.\nconstructor 메소드를 사용하여 생성할 경우에는 이런 것은 허용되지 않습니다. 
572 내부 에러: cannot build disk representation of instance.
573 내부 에러: 데이터베이스에 인스턴스를 새로 입력할 수 없습니다.
574 내부 에러: 데이터베이스에 인스턴스를 새로 갱신할 수 없습니다.
575 constructor %2$s의 %1$d 번째 인자에 대해 %3$s 타입을 예상했으나 %4$s 타입이 주어졌습니다. 
576 클래스 %3$s에 대한 참조는 %2$s의 %1$s 도메인과 호환되지 않습니다.
577 constructor %2$s의 %1$d 번째 인자에 대해 도메인은 unqualified 오브젝트에 대한 참조를 제공하기에는 충분치 않습니다.
578 클래스 %3$s에 대한 참조는 constructor %2$s의 %1$d 번째 인자의 도메인과 호환되지 않습니다. 
579 클래스에 대한 참조를 위해서는 대상 도메인이 "object" 타입을 포함해야 합니다.
580 애트리뷰트 %1$s은(는) 클래스 %2$s에 정의되지 않았습니다.
581 수정 불가능한 시점에서 데이터베이스를 수정하려고 하고 있습니다.
582 알 수 없는 볼륨 사용 용도 %1$d입니다. 정상적인 값은 %2$d ~ %3$d입니다.
583 유효하지 않은 페이지 수(%1$d)를 할당하려고 하고 있습니다. 
584 내부 에러: A loop was detected in the file table of file %1$d in volume "%2$s". The loop may be caused by page %3$d|%4$d.
585 알 수 없는 heap %1$s|%2$d|%3$d
586 내부 에러: Unable to update chain header in VPID %1$d|%2$d for heap %3$d in volume "%4$s".
587 "%1$s" volinfo 파일의 영구 볼륨 엔트리들이 정렬되어 있지 않습니다. 엔트리 %2$d: %3$d %4$s이(가) 순서를 벗어 났습니다.
588 내부 에러: Failed optimizer assertion. Optimization aborted.
589 사용자 이름 "%1$s"이(가) 잘못되었습니다.
590 클래스의 애트리뷰트 도메인 "%1$s"은(는) 가상클래스 또는 프락시 가상 클래스일 수 없습니다. 
591 프락시 가상 클래스의 애트리뷰트 도메인 "%1$s"은(는) 반드시 프락시 가상 클래스이어야 합니다.
592 프락시 가상 클래스의 애트리뷰트 도메인 "%1$s"와(과) 프락시 가상 클래스는 동일한 로컬 데이터베이스에 존재해야 합니다.  
593 갱신할 수 없는 가상 인스턴스가 회수되었으며 재생성할 수 없습니다.
594 object_id 절에 approximate 데이터 타입(float, double)을 가지는 애트리뷰트가 올 수 없습니다. 
595 데이터베이스 이름 "%1$s"이(가) 너무 깁니다. 데이터베이스 이름은 %2$d자 이내여야 합니다.
596 허용된 전체 임시 공간의 %1$s 페이지들이 초과되었습니다.
597 heap 파일 %1$d|%2$d|%3$d의 페이지 수가 일치하지 않습니다. heap chain을 통해 %4$d를, 파일 테이블을 통해 %5$d를 얻었습니다. 
598 파일의 개수가 일치하지 않습니다. %1$d을(를) 예상했으나, %2$d을(를) 얻었습니다. 
599 볼륨 "%1$s"을 sync하는 동안 I/O 에러가 발생했습니다.
600 기능 "%1$s"은(는) PC에서는 구현되어 있지 않습니다.
601 "%1$s".
602 dl 에러: "%1$s"이(가) 여러 번 정의되었습니다.
603 내부 에러: Sector/page table of file VFID %1$d|%2$d seems corrupted.
604 내부 에러: An allocation set for file VFID %1$d|%2$d(volume "%3$s") seems inconsistent in %4$d deleted or marked deleted pages and %5$d page holes in table
605 내부 에러: Inconsistent number of marked deleted pages for file VFID %1$d|%2$d(볼륨 "%3$s"). Expected %4$d, Found %5$d.
606 path "%1$s"에서 odbc.ini를 찾을 수 없습니다.
607 데이터베이스 "%1$s"이(가) odbc.ini 내에 정의되지 않습니다.
608 데이터베이스 "%1$s"의 호스트 명세가 odbc.ini 내에 정의되지 않습니다.
609 로깅하지 않았으므로 트랜잭션을 철회할 수 없습니다. 데이터베이스가 손상되었을 수 있습니다. 
610 데이터베이스에 장애가 발생했을 시점에 로깅하지 않았으므로 데이터베이스가 손상되었을 수 있습니다.
611 클라이언트 서버 모드에서는 %s (을)를 실행 할 수 없습니다.
612 복구해야 할 pending action이 있기 때문에 이 시점에서는 로깅을 disable할 수 없습니다.
613 도메인이 다르므로 클래스 "%3$s"의 "%1$s"을(를) 클래스 "%2$s"의 alias substitute로 활용할 수 없습니다. 
614 아카이브 로그의 개수가 허용 최대치 %1$d을(를) 초과했습니다.
615 윈속으로 연결할 수 없습니다. 윈속 에러: %1$d.
616 윈속을 통해 머신 이름을 알 수 없습니다. 윈속 에러: %1$d.
617 윈속을 통해 머신 ID를 알 수 없습니다. 호스트 이름 테이블에 이 머신에 대한 엔트리가 있어야 합니다. 윈속 에러: %1$d.
618 애트리뷰트가 수정될 수 없습니다.
619 잘못된 코드셋입니다.
620 변환 대상 코드셋이 잘못되었습니다.
621 유효하지 않은 데이터 타입입니다. 인자는 유효한 데이터 타입을 가져야 합니다.	
622 부적합한 코트셋입니다. 인자의 코드셋이 호환되지 않습니다.
623 유효하지 않은 escape sequence입니다. 유효하지 않은 escape sequence는 정규식 컴파일러에서 에러를 발생시킵니다.  
624 유효하지 않은 escape sequence입니다. Escape 문자는 길이가 1 이상인 NULL이 아닌 문자여야 합니다. 
625 내부 에러: Trying to update the wrong instance object %1$d|%2$d|%3$d attribute information template with instance object %4$d|%5$d|%6$d.
626 내부 에러: 요청된 %1$d 애트리뷰트를 찾을 수 없습니다.
627 trim 피연산자는 길이가 1 이상이어야 합니다. 
628 잘못된 통화(currency) 타입입니다: %d
629 페이지 사이즈 %1$d이(가) 2의 제곱이 아니거나 너무 작습니다. 페이지 사이즈 %2$d가(이) 대신 사용되었습니다. 
630 %1$s에 의한 변환은 지원되지 않습니다.
631 SQL 문장이 NOT NULL 제약 조건을 어겼습니다. 
632 %1$s은(는) 백업 볼륨이 아닙니다. 
633 %1$s은 %5$s에 생성된 데이터베이스 %4$s가 아니라 %3$s에 생성된 데이터베이스 %2$s에 대한 백업입니다. 
634 백업 볼륨 내에 데이터베이스 볼륨/파일이 없습니다.
635 경고: %1$d 버퍼의 로그 버퍼 풀이 현재 환경에 비해 너무 작은 것 같습니다.\n 알 수 없는 에러 때문이거나 너무 많은 동시 트랜잭션이 한꺼번에 취소되면서\n 시스템에 의해 버퍼들이 free 되지 않았을 가능성이 있습니다.\n  로그 버퍼 풀이 %2$d 버퍼 이상으로 확장되었습니다.
636 경고: Num_buffers %1$d이(가) 너무 작습니다. 최소값 %2$d이(가) 취해졌습니다. 
637 시스템 에러: 로그 버퍼를 너무 많이 free했습니다. Fix count가 0으로 되었습니다.
638 경고: 수정할 수 없는 로그 아카이브 페이지 ID:%1$d을(를) flush했습니다. 
639 시스템 에러: Previous log sequence page %1$d is not the delayed flush page %2$d.
640 시스템 에러: 트랜잭션이 active한 상태가 아닐 때에는 세이브포인트를 설정할 수 없습니다.
641 세이브포인트 이름이 주어져야 합니다. 
642 시스템 에러: there is not an active top system operation for current transaction.
643 May be a system error: Committing/Aborting transaction = %1$d (index = %2$d) which has permanent operations\n attached to it. Will attach those system operations to the transaction
644 시스템 에러: Log manager does not known either undo/redo function for rcvindex = %1$d
645 시스템 에러: State = %1$s of Transaction = %2$d (index = %3$d) \n is not the correct state to apply client postpone/undo actions... ignored
646 시스템 에러: It seems that a compensating record is missing for logical logging rcvindex = %s\n. Without this compensating record crash recovery will not be done correctly
647 백업 "%1$s"은(는) 주어진 데이터베이스에 속하지 않습니다. 
648 백업이 현재 "%1$s" release "%2$s"와 호환되지 않습니다.
649 주어진 precision %1$d는 유효하지 않습니다; %2$d에서 %3$d사이의 값이어야 합니다.
650 'max_clients=%1$d'를 위한 충분한 스레드를 생성하지 못했습니다.
651 %2$d 개의 스레드 각각에 정렬 버퍼 %1$d을(를) 할당할 수 없습니다.
652 slot %3$d에 저장된 길이 %2$d의 레코드를 나누기 위해 주어진 오프셋 %1$d은(는) 잘못되었습니다.
653 slot %4$d에 저장된 길이 %3$d의 레코드의 데이터 부분을 제거하기 위해 주어진 오프셋 %1$d나 길이 %2$d가 잘못되었습니다. 
654 slot %4$d에 저장된 길이 %3$d의 레코드의 데이터 부분을 overwrite하기 위해 주어진 오프셋 %1$d나 길이 %2$d가 잘못되었습니다. 
655 이벤트 처리 구성 파일 "%1$s"를 열 수 없습니다.
656 경고: 이벤트 처리 구성 파일 "%1$s"의 %2$d 라인에 id/name이 빠져있습니다.
657 경고: 이벤트 처리 구성 파일 "%1$s"의 %2$d 라인에 잘못된 이벤트 이름이 포함되어 있습니다.
658 경고: 파일 "%4$s"의 %5$d 라인의 이벤트 id %1$d, 에러 id가 범위 %2$d <> %3$d를 벗어났습니다.
659 이벤트 처리 프로그램 "%1$s"을(를) 액세스할 수 없습니다.
660 이벤트 처리 프로세스 "%1$s"를 open/connect할 수 없습니다.
661 이벤트 처리 프로세스 "%1$s"에 write할 수 없습니다.
662 이벤트 처리 메카니즘을 초기화할 수 없습니다.
663 경고:  이벤트 처리 구성 파일 "%1$s"의 %2$d 라인이 너무 길어서 단절되었습니다.
664 이벤트 처리 메카니즘 시작됨.
665 이벤트 처리 pipe가 손상되었습니다. "%1$s"
666 이벤트 처리 메카니즘 중지됨.
667 클래스 '%1$s'에 상응하는 C++ 클래스를 찾을 수 없습니다.
668 내부 에러: Unknown domain type '%1$d'.
669 최대 클라이언트 수 %1$d이(가) 초과되어 서버가 연결을 거부하였습니다.
670 오퍼레이션은 하나 또는 그 이상의 UNIQUE 제약 사항을 위반하였습니다.
671 트랜잭션(index %2$d, %3$s@%4$s|%5$d)에 연관된 socket %1$d에서 네트워크 read/write 에러가 발생하였습니다.
672 트랜잭션(index %2$d, %3$s@%4$s|%5$d)에 연관된 socket %1$d이 단절되었습니다.
673 서버가 다운되고 있기 때문에 서버로의 연결은 단절되었습니다.
674 현재 서버 수행을 지속할 수 있는 활성화된 스레드가 없습니다. 현재 활성화된 스레드의 개수는 %1$d이며, 현재 환경에서 서버 수행을 위해서는 %2$d 개의 스레드가 필요합니다. 트랜잭션 %3$d은 타임아웃되었습니다.
675 데이터베이스 위치 파일 "%1$s"을(를) 읽을 수 없습니다. 
676 데이터베이스 위치 파일 "%2$s"에서 데이터베이스 "%1$s"을(를) 찾을 수 없습니다.
677 호스트 %2$s에서 "%1$s" 데이터베이스 서버로 연결 설정할 수 없습니다.
678 내부 에러: Client restart module received NULL database server name.
679 해당 C++ 트랜잭션은 이미 시작된 상태입니다.
680 C++ 트랜잭션의 최대 내포 허용 값(%d)를 넘어서려고 하고 있습니다.
681 시작되지 않은 C++ 트랜잭션에서 %s 트랜잭션을 시도하고 있습니다.
682 모든 서브 트랜잭션들이 완료되지 않는 한 C++ 트랜잭션을 %s할 수 없습니다.
683 유효하지 않은 길이(%d)의 문자열을 생성하려고 하고 있습니다.
684 메소드가 사용자 정의 에러 코드 %d를 리턴 했습니다.
685 클래스 "%1$s"가 유효하지 않습니다.
686 통보: 이벤트 핸들러가 재 시작되지 않았습니다.
687 (%s *)로부터 (%s *)으로의 형 변환은 허용되지 않습니다.
688 첨자가 범위를 벗어났습니다. %ld 번째 엘리먼트를 액세스 하려고 하고 있습니다. collection 크기를 %ld입니다.
689 내부 에러: Iterator contains corrupt state.
690 초기화되지 않은 odb_Ref<>의 인스턴스를 참조하려고 하고 있습니다.
691 유효하지 않은 iterator를 사용하려고 하고 있습니다.
692 연관되지 않은 collection에 iterator를 사용하려고 하고 있습니다.
693 numeric 데이터 타입에 오버플로우 발생.
694 시스템 에러: B+tree를 로드할 수 없습니다.
695 클라이언트를 종료하는데 잘못된 인터페이스를 사용하였습니다.
696 알 수 없는 트랜잭션 입니다. (index %1$d, %2$s@%3$s|%4$d)
697 주어진 트랜잭션 인덱스 (index %1$d, %2$s@%3$s|%4$d)는 현재 트랜잭션 인덱스 (index %5$d, %6$s@%7$s|%8$d)와 맞지 않습니다. 주어진 트랜잭션은 이미 종료되었고 해당 트랜잭션 인덱스는 다른 트랜잭션에 의해 사용되고 있습니다. 
698 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). the number of OIDs in the unique hierarchy: %6$d does not equal the number of OIDs: %7$d found in the unique B+tree plus the number of NULLs: %8$d found in the unique hierarchy for B+tree: %9$d|%10$d|%11$d.
699 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). the number of OIDs in the unique hierarchy: %6$d does not equal the number of OIDs: %7$d found in the unique B+tree root statistics for B+tree: %8$d|%9$d|%10$d.
700 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). the number of OIDs: %6$d does not equal the number of NULLs: %7$d plus the number of keys: %8$d in the unique B+tree: %9$d|%10$d|%11$d.
701 ldb "%2$s"의 "%1$s"에서 프락시가 정의되지 않았습니다.
702 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). the number of NULLs in the unique hierarchy: %6$d does not equal the number of NULLs: %7$d found in the unique B+tree root statistics for B+tree: %8$d|%9$d|%10$d.
703 내부 에러: INDEX %1$s ON CLASS %2$s (CLASS_OID: %3$d|%4$d|%5$d). OID: %6$d|%7$d|%8$d found in unique B+tree: %9$d|%10$d|%11$d does not belong to one of the classes for the unique constraint.
704 Evaluation of generic server function failed.
705 %2$d 개이어야 하나 %1$d 개의 영구 볼륨이 발견되었습니다.
706 볼륨 용도 %2$s의 영구 볼륨 "%1$s"을(를) 확장할 수 없습니다. 
707 %2$d 페이지의 임시 볼륨 "%1$s"을(를) 확장할 수 없습니다.
708 여유 공간이 부족하여 %2$d 페이지(%3$d K바이트)의 임시 볼륨 "%1$s"을 확장할 수 없습니다. 사용 가능한 여유 공간은 %4$d 페이지(%5$d K바이트)입니다.
709 "%1$s" 제약 사항이 없습니다.
710 유효하지 않은 제약 사항입니다.
711 주어진 애트리뷰트 값을 가지는 오브젝트는 존재하지 않습니다.
712 "%1$s" 제약 사항은 이미 존재합니다.
713 해당 애트리뷰트에 인덱스가 존재하지 않습니다.
714 임시 파일의 여유 공간이 부족하여 질의가 실패하였습니다.
715 스키마를 검증할 수 없습니다.: %1$s
716 가상 또는 프락시 클래스에는 NOT NULL 제약 사항이 허용되지 않습니다.
717 가상 또는 프락시 클래스에는 UNIQUE 제약 사항이 허용되지 않습니다.
718 Invalid gadget.
719 애트리뷰트의 개수(%d)와 값의 개수(%d)가 다릅니다.
720 가상 또는 프락시 클래스에 gadget을 이용하여 삽입할 수 없습니다.
721 삽입 결과가 한 건 이상입니다.
722 NOT NULL 제약 사항에 대해 잘못된 애트리뷰트 개수입니다.
723 존재하는 애트리뷰트의 도메인을 변경할 수는 없습니다.
724 디폴트 제약 사항 이름 생성 시에 잘못된 인자가 주어졌습니다.
725 내부 에러: expected temporary oid and encountered permanent oid.
726 인스턴스가 이미 생성된 후에는 UNIQUE 제약 사항은 별도의 alter 문장을 통해 추가되어야 합니다. 예를 들어,\n\t alter table1 add attribute a int unique;\n\t 대신 \n\t alter table1 add attribute a int;\n\t alter table1 add unique(a);\n\t 형태를 사용하십시오.  
727 유효하지 않은 트리거 이벤트 입니다.
728 트랜잭션 %1$d에 대한 임시 파일의 vfid가 유효하지 않으므로 질의가 실패하였습니다.
729 뺄셈에서 오버플로우가 발생하였습니다.
730 곱셈에서 오버플로우가 발생하였습니다.
731 나눗셈에서 오버플로우가 발생하였습니다.
732 부호 변환 시에 오버플로우가 발생하였습니다.
733 형 변환 시에 오버플로우가 발생하였습니다.
734 내부 에러: Header of file VFID %1$d|%2$d(Volume "%3$s") is corrupted.
735 알 수 없는 트랜잭션 인덱스 %1$d입니다.
736 서비스 내지는 포트 번호를 지정해야 합니다. 윈속 에러: %1$d.
737 알 수 없는 TCP 서비스 입니다: %1$s. 윈속 에러: %2$d.
738 socket 스트림을 생성할 수 없습니다. 윈속 에러: %1$d.
739 주소에 bind할 수 없습니다... 재시도 중. 윈속 에러: %1$d.
740 주소에 bind할 수 없습니다... 취소 중. 윈속 에러: %1$d.
741 Accept 실패. 윈속 에러: %1$d.
742 클라이언트에 broadcast 메시지를 보내고 있습니다. 윈속 에러: %1$d.
743 클라이언트와 서버 사이의 handshake 실패. (peer host %s)
744 Error in rehashing a proxy/vclass MOP.
745 Invalid garbage collection phase.
746 Invalid garbage collection callback.
747 Invalid garbage collection callback ticket.
748 Invalid object pointer encountered by db_gc_mark_object.
749 fetch된 인스턴스 수가 정확하지 않습니다: %1$d 개를 예상했으나, %2$d 개를 얻었습니다.
750 fetch된 애트리뷰트 수가 정확하지 않습니다: %1$d 개를 예상했으나, %2$d 개를 얻었습니다.
751 BEFORE INSERT 트리거에서는 새 오브젝트의 OID를 알 수 없습니다.
752 Error restoring backup unit_num %d.
753 Error restoring backup unit_num %d, pageid %d exceeds total number of pages %d for volid %d.
754 OO 프락시 인스턴스가 문자열 타입이 아니거나 NULL 키를 가지고 있습니다.
755 스탠드-얼론 모드에서는 %s 을(를) 실행 할 수 없습니다.
756 지정된 문자열 버퍼가 해당 오브젝트를 인코딩 하기에는 너무 작습니다. 
757 내부 에러: cannot assign permanent OID during object encode.
758 지정된 문자열 버퍼가 해당 오브젝트를 디코딩하기에 적합하지 않습니다.
759 대상 오브젝트는 이미 삭제되었습니다.
760 내부 에러: proxy object instance has NULL key during object encode.
761 내부 에러: vclass object instance maps to invalid real instance.
762 내부 에러: in resolving vclass instance to a real instance.
763 내부 에러: in encoding nonupdatable object instance.
764 내부 에러: in encoding object into internal vobj form.
765 출력 오브젝트 인자가 NULL 주소를 갖고 있습니다.
766 내부 에러: in decoding object.
767 레벨 %2$d 백업하지 않은 상태에서 레벨 %1$d 백업할 수 없습니다.
768 현재 세션에서 데이터베이스 "%1$s"이(가) 액세스되었으므로, 변경이나 제거할 수 없습니다.
769 클래스 "%2$s"의 애트리뷰트 "%1$s"는 유효하지 않은 class/shared 애트리뷰트입니다.
770 No table functions.
771 함수가 유효하지 않은 인자가 주어졌습니다.
772 db_serial 클래스를 찾을 수 없습니다.
773 Serial "%s"을(를) 찾을 수 없습니다.
774 Serial "%s"은(는) 이미 존재합니다. 
775 Serial의 next value가 최대(최소) 값을 초과합니다.
776 serial 오브젝트를 읽을 수 없습니다.
777 serial 오브젝트를 수정할 수 없습니다.
778 "%s"에서 "%s"(으)로의 링크를 만들 수 없습니다.
779 DATE 타입의 범위를 넘었습니다. DATE는 1~9999 년이 유효한 범위입니다.
780 내부 시스템 에러: 시스템 시간을 얻을 수 없습니다.
781 포맷문자열의 길이가 너무 깁니다. 포맷 문자열은 16K를 초과할 수 없습니다. 
782 빈 문자열(empty string)은 쓸 수 없습니다.
783 잘못된 포맷입니다. 
784 두 인자가 어울리지 않습니다. 
785 첫 번째 인자의 길이가 너무 깁니다. 인자의 길이는 16K를 초과할 수 없습니다. 
786 포맷이 중복되었습니다. 
787 time 포맷 변환 에러.
788 timestamp 포맷 변환 에러.
789 숫자가 틀렸습니다. 
790 질의 수행 중 사용자에 의해 인터럽트 되었습니다.
791 잘못된 Serial 값입니다.
792 css 모듈에서 메모리를 할당할 수 없습니다.
793 pthread_attr_init() 호출 실패.
794 pthread_attr_destroy() 호출 실패.
795 pthread_attr_setdetachstate() 호출 실패.
796 pthread_attr_setscope() 호출 실패.
797 pthread_attr_setstacksize() 호출 실패.
798 pthread_create() 호출 실패.
799 pthread_join() 호출 실패.
800 pthread_mutex_init() 호출 실패.
801 pthread_mutex_destroy() 호출 실패.
802 pthread_mutex_lock() 호출 실패.
803 pthread_mutex_trylock() 호출 실패.
804 pthread_mutex_unlock() 호출 실패.
805 pthread_mutexattr_init() 호출 실패.
806 pthread_mutexattr_destroy() 호출 실패.
807 pthread_mutexattr_settype() 호출 실패.
808 pthread_mutexattr_gettype() 호출 실패.
809 pthread_cond_init() 호출 실패.
810 pthread_cond_destroy() 호출 실패.
811 pthread_cond_wait() 호출 실패.
812 pthread_cond_timedwait() 호출 실패.
813 pthread_cond_signal() 호출 실패.
814 pthread_cond_broadcast() 호출 실패.
815 pthread_key_create() 호출 실패.
816 pthread_key_delete() 호출 실패.
817 pthread_setspecific() 호출 실패.
818 pthread_getspecific() 호출 실패.
819 pthread_once() 호출 실패.
820 connection을 초기화할 수 없습니다.
821 connection을 종료합니다.
822 클라이언트 id를 얻기 위한 과정에서 mutex operation이 실패하였습니다.
823 connection 리스트 초기화 과정에서 mutex operation이 실패하였습니다.
824 connection 리스트 제거 과정에서 mutex를 제거할 수 없습니다.
825 pread() 호출 실패.
826 pwrite() 호출 실패.
827 connection 리스트 읽는 과정에서 실패하였습니다.
828 잘못된 critical section을 접근하였습니다.
829 mutex 잠금이 이미 해제된 상태입니다.
830 query entry를 더 이상 할당할 수 없습니다. 허용 가능한 최대값은 %d 입니다.
831 최대 transaction descriptors 값인 %d개가 모두 사용 중입니다. 
832 백업이 이미 실행 중입니다. 두 개 이상의 백업이 동시에 진행될 수 없습니다.
833 인덱스 이름 "%1$s"가 불분명합니다. 인덱스의 클래스 이름을 지정하십시오.
834 to_number() 함수에 주어진 source 문자열 "%1$s"과 format 문자열 "%2$s"이 매칭되지 않습니다.
835 정의되지 않은 통계 아이템입니다.
836 페이지(%d|%d)에 대한 래치 획득 요청이 시간을 초과하였습니다.
837 데이터베이스 객체(클래스/뷰/트리거/serial 등)을 소유한 사용자는 삭제할 수 없습니다.
838 동시에 %d개를 초과하는 인덱스 스캔을 열 수 없습니다.
839 "%s": 알 수 없는 시스템 파라미터 이거나 값이 잘못되었습니다.
840 시스템 파라미터 "%s"를 바꿀 수 없습니다.
841 요청된 작업은 한 클라이언트(트랜잭션)만 있을 때 가능합니다.
842 오브젝트(%1$d|%2$d|%3$d)의 락을 캐쉬할 수 없습니다.
843 %s 함수의 잘못된 인자로 %s가 넘어왔습니다.
844 알 수 없는 격리도(%d)가 발견되었습니다. 해당 트랜잭션 인덱스는 %d입니다.
845 잘못된 객체 유형(%d)이 발견되었습니다. 해당 로크 객체는 %d|%d|%d입니다..
846 %s을 획득한 트랜잭션(%d)은 해당 객체(%d|%d|%d)의 holder list에 없습니다.
847 %s이 획득된 %s(%d|%d|%d)는 해당 트랜잭션(%d)의 hold list(cnt=%d)에 없습니다.
848 %s이 획득된 객체(%d|%d|%d)는 해당 트랜잭션(%d)의 non2pl list에 없습니다.
849 트랜잭션(%d)을 두 번 이상 취소(abort)시키려고 합니다.
850 트랜잭션(%d)은 로크 객체(%d|%d|%d)의 holder도 아니고 waiter도 아닙니다.
851 로크 자원 (%s) 할당 실패.
852 빈 lock holder list의 total holders mode(%d)가 NULL_LOCK이 아닙니다.
853 객체(%d|%d|%d)에 대해 Uncommitted Read 트랜잭션(%d)이 잘못된 로크(%s)를 잡았습니다.
854 경고: lock holder는 없지만 lock waiter는 존재하는 상태. %s를 참조하세요.
855 경고: 둘 이상의 스레드가 하나의 트랜잭션(%d)를 위해 lock-waiting 중입니다.
856 경고: 이상한 로크 대기 상태(%d|%d), 스레드는 (%d|%d), 트랜잭션은 (%d).
857 볼륨 "%2$s"의 %1$d 페이지를 잘라내는 도중에 I/O 에러 발생.
858 서버 재수행시 볼륨 "%1$s"는 알 수 없는 볼륨입니다. 
859 페이지(%d|%d)에 대한 래치 획득 요청이 취소되었습니다.
860 현 트랜잭션의 상태(%1$s)가 잘못되어 글로벌 트랜잭션에 참여할 수 없습니다.
861 현 트랜잭션(식별자 %1$d)은 글로벌 트랜잭션에 참여하고 있지 않으므로 prepare 할 수 없습니다.
862 글로벌 트랜잭션(식별자 %1$d)의 상태가 %2$s이므로 사용자 정보를 설정할 수 없습니다.
863 글로벌 트랜잭션(식별자 %1$d)의 사용자 정보가 없습니다.
864 backupdb/restoredb verbose 파일 '%s' 을 열 수 없습니다. 
865 타입을 알 수 없는 input markers 때문에 문장을 수행할 수 없습니다.
866 사용하지 않는 에러코드입니다.
867 사용하지 않는 에러코드입니다.
868 사용하지 않는 에러코드입니다.
869 사용하지 않는 에러코드입니다.
870 사용하지 않는 에러코드입니다.
871 사용하지 않는 에러코드입니다.
872 사용하지 않는 에러코드입니다.
873 PKI 인증 에러입니다. "%1$s"
874 power() 함수의 인자가 유효하지 않습니다.
875 power 수행 중 오버플로우가 발생했습니다.
876 사용하지 않는 에러코드입니다.
877 언로드 할 자료가 없습니다.
878 데이터베이스 위치 파일 "%1$s"에 오류가 있습니다.
879 파일 '%s' 권한을 가져오지 못했습니다.
880 파일 '%s' 권한의 변경에 실패했습니다
881 파일 '%s(파일ID:%d)'의 lock을 획득하는데 실패했습니다.
882 '파일ID:%d'의 lock을 해제하는데 실패했습니다.
883 '%s'의 파일 정보를 가져오는데 실패했습니다.
884 '%s'는 쓸 수 없습니다.
885 '%s'에서 '%s'로 이동하는데 실패 했습니다. 다른 장치(디스크)로 이동할 수 없습니다. 
886 "%1$s" 이(가) UNIQUE 제약 사항을 위반하였습니다.
887 Stored Procedure '%s' 가 이미 존재합니다.
888 매개변수 개수가 일치하지 않습니다. 기대: %d, 실제: %d
889 Stored procedure 실행 오류: %s 
890 파티션 작업 오류입니다.
891 해당되는 파티션이 존재하지 않습니다.
892 클래스 "%1$s"에 primary key "%2$s"가 이미 존재합니다.
893 애트리뷰트 '%1$s'는 primary key의 멤버이므로 삭제할 수 없습니다.
894 Stored procedure/function '%s' 가 존재하지 않습니다.
895 Stored Procedure 유형이 잘못되었습니다: '%s'는 '%s' 입니다.
896 압축 오류입니다. 압축 방법: %d (%s), 압축 레벨: %d (%s)
897 압축 해제 오류입니다.
898 복제 오류가 발생했습니다: "%1$s"
899 잘못된 파티션 작업 요구입니다.
900 Java 가상 머신 라이브러리를 찾을 수 없습니다: %s. \n그러므로, java stored procedure를 호출할 수 없습니다.
901 Java 가상 머신을 시작할 수 없습니다: %s. \n그러므로, java stored procedure를 호출할 수 없습니다.
902 Java 가상 머신이 실행되지 않았습니다.
903 Java 가상 머신에 접속할 수 없습니다: %s
904 잘못된 Stored Procedure 이름입니다.
905 Java 가상 머신과 통신 중 오류가 발생하였습니다: %d
906 잘못된 자바 메소드입니다.
907 소유자나 DBA 그룹의 멤버만이 대상 stored procedure를 삭제(drop)할 수 있습니다.
908 Stored procedure '%s'의 매개변수가 너무 많습니다.
909 카탈로그 클래스/가상 클래스를 찾을 수 없거나, 잘못된 엔트리입니다.
910 허용되지 않는 파티션 접근 입니다.
911 허용되지 않는 호출: ResultSet을 반환할 수 없습니다.
912 ResultSet는 입력 매개변수로 사용할 수 없습니다.
913 중첩된 Stored Procedure 호출이 허용된 횟수를 초과하였습니다.
914 Auto increment 제약조건으로 정의할 시리얼 객체가 이미 존재합니다.
915 Auto increment 제약조건의 증가 값은 0보다 커야 합니다.
916 활동 로그 볼륨이 포함되지 않은 백업(%s)볼륨 입니다.
917 활동 로그 볼륨이 이미 존재합니다.
918 외래키가 참조하는 클래스 '%s'가 존재하지 않습니다.
919 외래키가 참조하는 클래스 '%s'가 기본키를 가지고 있지 않습니다.
920 외래키 '%s'에 기본키 멤버 '%s'가 포함되어 있지 않습니다.
921 외래키 멤버 '%s'의 도메인이 기본키 멤버 '%s'의 도메인과 다릅니다.
922 외래키 '%s' 제약조건에 위배되었습니다.
923 외래키 '%2$s'에 참조되는 기본키 '%1$s'는 삭제할 수 없습니다.
924 수정/삭제 연산이 외래키 '%s'에 의해 제약되었습니다.
925 외래키 '%s'를 위한 잠금 획득에 실패했습니다.
926 외래키 '%s'를 가진 인스턴스를 삭제하지 못했습니다.
927 외래키 '%s'의 키 개수와 기본키 '%s'의 키 개수가 다릅니다.
928 외래키 'ON CACHE OBJECT'절로 생성된 속성 '%s'에는 사용자가 직접 값을 할당할 수는 없습니다.
929 외래키를 가상 클래스에 정의할 수 없습니다.
930 외래키 'ON CACHE OBJECT'절로 생성된 속성 '%s'는 외래키 제약조건을 제거한 후에만 삭제할 수 있습니다.
931 Auto increment 제약조건의 시작 값은 최대값보다 작아야 합니다. 
932 볼륨 "%1$s"에 대한 free 페이지 수 불일치를 고칠 수 없습니다. 볼륨 헤더에서 얻은 %2$d와 비트맵에서 얻은 %3$d이 다르기 때문입니다.
933 볼륨 "%1$s"에 대한 sector 페이지 수 불일치를 고칠 수 없습니다. 볼륨 헤더에서 얻은 %2$d와 비트맵에서 얻은 %3$d이 다르기 때문입니다.
934 NULL 도메인이 언급되었습니다.
935 함수 %s의 인자의 범위가 정상 범위를 넘었습니다.
936 exp 수행 중 오버플로우가 발생했습니다.
937 데이터베이스 에러.
938 유효하지 않은 인자.
939 너무 많은 연결 존재.
940 핸들이 유효하지 않습니다.
941 해당 operation은 지원되지 않습니다.
942 핸들을 얻기 위한 lock에서 타임아웃 발생.
943 에러.
944 문장이 준비 되지 않았습니다.
945 문장에 결과 집합이 없습니다.
946 문장이 실행되지 않았습니다.
947 더 이상의 결과 집합이 없습니다.
948 버퍼의 크기가 부족합니다.
949 더 이상의 가용한 정보가 없습니다.
950 이름이 유효하지 않습니다.
951 결과 집합이 수정 가능하지 않습니다.
952 행이 지워졌습니다.
953 준비된 문장의 인자가 설정되지 않았습니다.
954 문장이 batch 문장이 아닙니다.
955 해당 batch 문장을 비울 수 없습니다.
956 batch 수행 에러.
957 준비된 문장입니다.
958 준비된 문장이 아닙니다.
959 batch 문장입니다.
960 더 이상의 에러가 없습니다.
961 더 이상의 결과가 없습니다.
962 메모리 부족.
963 브로커 에러.
964 결과 집합의 핸들이 닫혔습니다.
965 인덱스 키 리스트에 중복된 속성 이름이 허용되지 않습니다.  속성 이름인 '%s' (이)가 두 번 이상 나열 되었습니다.
966 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) %6$d|%7$d|%8$d 오브젝트에 대한 %5$s 락 대기 중에 데드락으로 인해 타임아웃 되었습니다. 사용자 %9$s 이(가) 종료할 때까지 기다리고 있었습니다. 
967 트랜잭션이(인덱스 %1$d, %2$s@%3$s|%4$d) %6$s 클래스에 대한 %5$s 락 대기 중에 데드락으로 인해 타임아웃 되었습니다. 사용자 %7$s 이(가) 종료할 때까지 기다리고 있었습니다.
968 트랜잭션이(인덱스  %1$d, %2$s@%3$s|%4$d) %9$s 클래스의 %6$d|%7$d|%8$d 인스턴스에 대한 %5$s 락 대기 중에 데드락으로 인해 타임아웃 되었습니다. 사용자 %10$s 이(가) 종료할 때까지 기다리고 있었습니다.
969 서버 플랫폼(%1$s 비트)은(는) 클라이언트 플랫폼(%2$s 비트)와(과) 다릅니다.
970 서버의 HA 모드가 '%1$s'에서 '%2$s'로 변경되었습니다.
971 프로그램 '%1$s' (pid %2$d)가 호스트 '%4$s' (포트 %5$d) 의 데이터베이스 서버 '%3$s'에 접속되었습니다.
972 프로그램 '%1$s' (pid %2$d)가 호스트 '%3$s'로부터 접속되었습니다. (트랜잭션 인덱스 %4$d)
973 서버 상태 %1$s
974 %2$d에서 %3$d까지의 페이지들을 archive하기 위한 archive 로그 "%1$s"를 생성했습니다.
975 현재 버전의 복제는 하나의 UPDATE 질의로 여러 레코드를 변경시키는 것이 UNIQUE 제약을 위반하는 경우 허용되지 않습니다.
976 내부 에러: 파일 테이블의 사이즈가 초과했습니다. (할당된 사이즈: %1$d, 사용된 사이즈: %2$d) 발생한 테이블 페이지의 위치 %3$d|%4$d (볼륨명: "%5$s")
977 체크포인트가 시작되었습니다. (페이지 %d)
978 체크포인트가 완료되었습니다. (페이지 %d)
979 CONNECT BY 질의문 수행 중에 루프가 발견되었습니다.
980 쓰레드가 %2$d msec 동안 %1$s 대기했습니다.
981 트랜잭션 %1$d이 모니터링 통계값 %2$s의 임계치를 넘었습니다.
982 트랜잭션 %1$d에 인터럽트 설정
983 해당 테이블에 대해 허용되지 않는 작업이 시도되었습니다. REUSE_OID 옵션이 정의된 테이블 내 레코드를 참조할 수 없습니다.
984 설정 파일 "%1$s"의 "[%2$s]" 섹션에서 %3$s가 "%4$s"로 설정되어 있으면 "[%5$s]" 섹션에서 "%6$s"로 설정할 수 없습니다. 
985 "databases.txt"에 다중 호스트가 설정된 경우에는 데이터베이스 연결 문자열에 호스트 이름이 지정되어야 합니다.
986 CUBRID heartbeat 기능을 시작합니다.
987 CUBRID heartbeat 기능을 정지합니다.
988 노드 이벤트: %1$s.
989 프로세스 이벤트: %1$s. %2$s
990 명령어 수행: %1$s. %2$s
991 페이지 버퍼의 희생자 후보 flush가 시작되었습니다.
992 페이지 버퍼의 희생자 후보 flush가 완료되었습니다. (count: %d)
993 비트 연산 수행 중 오버플로우가 발생하였습니다.
994 prepared statement로 사용될 수 없는 질의문입니다.
995 %1$s 이름이 지정된 prepared statement가 존재하지 않습니다.
996 주어진 값의 개수가 정확하지 않습니다. %1$d 개의 값이 아니라, %2$d 개의 값이 지정되어야 합니다.
997 외래 키 제약 조건 %1$s 를 파티션 테이블 %2$s에 추가할 수 없습니다. 파티션 테이블에서는 업데이트 연산에 대해 참조 동작을 정의할 수 없습니다.
998 외래 키 제약 조건 %1$s 를 컬럼 %2$s에 추가할 수 없습니다. NOT NULL 제약 조건이 정의된 컬럼에 대해 참조 동작 옵션으로 SET NULL을 정의할 수 없습니다.
999 원본 테이블'%2$s'에서 테이블 '%1$s'를 생성할 수 없습니다. 원본 테이블에 복제할 수 없는 스키마가 정의되어 있습니다(%3$s).
1000 '%1$s'은 CLASS 또는 SHARED 속성 컬럼입니다. 일반적인 컬럼에만 허용되는 작업입니다.
1001 예상하지 못한 상황이 발생되었습니다. '%1$s'
1002 현재 트랜잭션이 작업을 계속하는데 필요한 데이터베이스 락을 획득하지 못하였습니다.
1003 동일한 이름으로 타입이 다른 제약 조건 '%1$s'이 존재합니다.
1004 Please note that when using ALTER TABLE DROP FOREIGN KEY, MySQL will drop just the FOREIGN KEY constraint and keep its associated index. CUBRID drops both the constraint and its associated index.
1005 현재 CUBRID 버전의 REPLACE문은 트리거와 같이 클라이언트 측에서 동작하는 기능을 지원하지 않습니다. 서버 측에서 수행하는 경우라면, insert_execution_mode의 설정을 확인하십시오.
1006 현재 CUBRID 버전의 ON DUPLICATE KEY UPDATE문은 트리거와 같이 클라이언트 측에서 동작하는 기능을 지원하지 않습니다. 서버 측에서 수행하는 경우라면, insert_execution_mode의 설정을 확인하시고 hostvar_late_binding 파라미터 값이 no인지 확인하십시오. 
1007 UNIQUE, FOREIGN KEY, PRIMARY KEY 생성 시 컬럼에 prefix length를 명시할 수 없습니다.
1008 파티션 테이블에 대해 인덱스 생성 시 컬럼에 prefix length를 명시할 수 없습니다.
1009 COMPACTDB 작업이 이미 시작되었습니다. 
1010 "%1$s" 타입 컬럼에 대해 prefix length를 명시하여 인덱스를 정의할 수 없습니다.
1011 외래 키 제약 조건 %1$s 를 SHARED 속성 컬럼 %2$s에 추가할 수 없습니다.
1012 NULL 타입 컬럼이 포함된 테이블은 생성할 수 없습니다.
1022 Node name is too long, the max length is %1$d.
1023 Host name is too long, the max length is %1$d.
1024 Cannot get the valid IP address from DB host. The address should be valid and cannot be local address.
1025 After convert DB host to IP address, detected the IP address is already in cluster.
1026 Current DB is not in cluster. Cannot register other DB now, please register current DB firstly.
1027 The port value is invalid. Please give a valid port number. The port number should greater then 0 and smaller than 65536.
1028 Duplicate node. The node name is already be used in cluster.
1029 The node does not exist in cluster.
1030 The node contains cluster data, such as global table or other.
1031 Cannot get current connected node information.
1032 The number of participant is exceeded, the max number is %1$d.
1033 The max number of cluster node is exceeded, the max number is %1$d.
1034 The remote server execution failed. Remote host id is %1$d.
1035 The remote server scan failed. Remote host id is %1$d.
1036 The remote server end failed. Remote host id is %1$d.
1037 Get the OID of GLOBAL SERIAL from remote failed.
1038 Get the cache value of GLOBAL SERIAL from remote failed.
1039 Don't support Cluster operation in SA mode.
1040 Unexpected datatype for server to server communication.

1041 마지막 에러

$set 6 MSGCAT_SET_INTERNAL
1 에러 서브 시스템에 에러 발생(라인 %d):
2 에러 메시지를 사용할 수 없습니다.
3 %d 바이트를 할당할 수 없습니다.
4 메세지 카탈로그 "%s"을(를) 찾을 수 없습니다.
5 에러 코드 %d에 대한 메시지가 없습니다.
6 ... 즉시 ABORT/EXIT 합니다 ...\n
7 종료하시겠습니까? 1/0
8 파일을 찾을 수 없습니다.
9 사용할 수 없는 메시지입니다; 이 메시지는 잘못 포맷되어 다른 내용으로 바뀌었습니다.
10 er_init: *** 부정확한 exit_ask 값 = %d; 대신에 %s로 간주합니다. ***\n
11 er_start: *** 경고: 메세지 로그 "%s"을(를) 열 수 없습니다.; 대신에 stderr을 사용합니다. ***\n
12 er_study_fmt: suspect message for error code %d.
13 er_estimate_size: 알 수 없는 변환 코드 (%d).
14 \n\n***  메시지 로그 wraparound. 메시지들은 파일에서 다시 시작됩니다. ***\n\n
15 \nTime: %s - %s *** %s 코드 = %d, Tran = %d%s\n%s\n<<<---\n
16 CUBRID (pid:%d) *** %s *** %s 코드 = %d, Tran = %d %s
17 \nTime: %s - %s *** 파일 %s, 라인 %d %s 코드 = %d Tran = %d%s\n%s\n<<<---\n
18 CUBRID (pid: %d) *** %s *** 파일 %s, 라인 %d, %s 코드 = %d, Tran = %d. %s
19 \n*** 이전 에러 메시지가 마지막 입니다.  ***\n\n
20 \nTime: %s - DEBUG *** 파일 %s, 라인 %d\n<<<---\n
21 Mail -s "Server가 멈추었습니다."
22 --->>>\n %s has been stopped at your request when the following error was set:\n errid = %d, %s\nUser: %s, pid: %d, host: %s, time: %s<<<---\n
23 %s has been stopped on errid = %d. User: %s, pid: %d
24 er_init: cannot install event handler "%s"\n

$set 7 MSGCAT_SET_PARSER_SYNTAX
1 '%s'의 문법을 점검해 주십시오. %s가(이) 기대됩니다.
2 '%1$s'의 문법을 점검해 주십시오. %3$s 안의 %2$s가 기대됩니다.
3 토큰 '%s'의 정확성을 점검해 주십시오.
4 'read uncommitted schema'는 허용되지 않습니다.\n대신에 'read committed schema'를 이용 하시기 바랍니다.
5 최대 문자열 길이는 16383 입니다.
6 %s는(은) %ld의 한계를 초과 했습니다.
7 비트 문자열의 최대 크기는 %d 비트입니다.
8 조인 조건에는 부 질의를 사용할 수 없습니다.
9 grant/revoke 문의 update 권한 부분에 에트리뷰트"(%s)"를 지정할 수 없습니다.
10 키워드 '%s'를 잘못 사용하였습니다. %s가(이) 기대됩니다.
11 토큰 길이가 너무 큽니다.
12 data type 이 잘못되었습니다.
13 잘못된 형식의 attach 구문입니다.\n  attach_statement: ATTACH unsigned_integer
14 잘못된 형식의 prepare 구문입니다.\n  prepare_statement:  PREPARE {to} COMMIT unsigned_integer
15 잘못된 형식의 execute 구문입니다.\n  execute_statement:  EXECUTE DEFERRED TRIGGER [identifier {, identifier}* | ALL TRIGGERS]
16 잘못된 형식의 scope 구문입니다.\n  scope_statement: SCOPE trigger_action { FROM table_spec_list }
17 잘못된 형식의 set system parameter 구문입니다.\n  set_system: SET SYSTEM PARAMETERS 'STRING' {, 'STRING_N'}*
18 잘못된 형식의 set transaction 구문입니다.\n  set_transaction: SET TRANSACTION ISOLATION LEVEL expression {, expression}\n                 | SET TRANSACTION LOCK TIMEOUT timeout_spec
19 잘못된 형식의 set trigger trace 구문입니다.\n  set_trigger: SET TRIGGER TRACE [ON|OFF|unsigned_integer|parameter|host_param]
20 잘못된 형식의 set trigger depth 구문입니다.\n  set_trigger: SET TRIGGER {MAXIMUM} DEPTH [INFINITE|unsigned_integer|parameter|host_param]
21 잘못된 형식의 set optimization level 구문입니다.\n  SET OPTIMIZATION LEVEL {=|to} [ON|OFF|unsigned_integer|parameter|host_param]
22 잘못된 형식의 set optimization cost 구문입니다.\n  SET OPTIMIZATION COST {of} 'STRING' {=|to} literal_
23 잘못된 형식의 get optimization level 구문입니다.\n  GET OPTIMIZATION LEVEL {[INTO|TO] [host_param|parameter|identifier]}
24 잘못된 형식의 get optimization cost 구문입니다.\n  GET OPTIMIZATION COST {of} 'STRING' {[INTO|TO] [host_param|parameter|identifier]}
25 잘못된 형식의 get transaction isol 구문입니다.\n  GET TRANSACTION ISOL LEVEL {[INTO|TO] [host_param|parameter|identifier]}
26 잘못된 형식의 get transaction lock 구문입니다.\n  GET TRANSACTION LOCK TIMEOUT {[INTO|TO] [host_param|parameter|identifier]}
27 잘못된 형식의 get trigger trace 구문입니다.\n  GET TRIGGER TRACE {[INTO|TO] [host_param|parameter|identifier]}
28 잘못된 형식의 get trigger depth 구문입니다.\n  GET TRIGGER {MAXIMUM} DEPTH {[INTO|TO] [host_param|parameter|identifier]}
29 잘못된 형식의 get stat 구문입니다.\n  GET STATISTICS 'STRING' {[INTO|TO] [host_param|parameter|identifier]}
30 잘못된 형식의 create index 구문입니다.\n  CREATE {REVERSE} {UNIQUE} INDEX {identifier} ON {only} class_name index_column_name_list
31 잘못된 형식의 create user 구문입니다.\n  CREATE USER identifier {PASSWORD 'STRING'} {GROUPS identifier {, identifier}* } {MEMBERS identifier {, identifier}* }
32 잘못된 형식의 create trigger 구문입니다.\n  CREATE TRIGGER identifier {STATE [ACTIVE|INACTIVE]} {PRIORITY unsigned_real}\n    [BEFORE|AFTER|DEFERRED] event_spec {IF trigger_condition}\n    EXECUTE {AFTER|DEFERRED} trigger_action
33 잘못된 형식의 create serial 구문입니다.\n  CREATE SERIAL identifier {START WITH integer} {INCREMENT BY integer}\n    serial_min_max {CYCLE|NOCYCLE} {CACHE unsigned_integer|NOCACHE}
34 잘못된 형식의 create procedure 구문입니다.\n  CREATE PROCEDURE identifier '(' {sp_param_list} ')' {IS|AS} LANGUAGE JAVA NAME 'STRING'
35 잘못된 형식의 create function 구문입니다.\n  CREATE FUNCTION identifier '(' {sp_param_list} ')' RETURN {data_type|CURSOR} {IS|AS} LANGUAGE JAVA NAME 'STRING'
36 잘못된 형식의 groups 구문입니다.\n  groups spec: GROUPS identifier {, identifier}*
37 잘못된 형식의 members 구문입니다.\n  member spec: MEMBERS identifier {, identifier}*
38 잘못된 형식의 password 구문입니다.\n  password spec: PASSWORD 'STRING'
39 authorized command list 가 빠졌습니다.\n  authorized command = SELECT, INSERT, INDEX, DELETE, UPDATE, ALTER, ADD, DROP, EXECUTE, REFERENCES, ALL PRIVILEGES, ALL 
40 class spec list 가 빠졌습니다.
41 identifier list 가 빠졌습니다.
42 expression 이 기대됩니다.
43 잘못된 형식의 identifier 입니다.
44 substring 함수의 형식이 잘못되었습니다.\n  SUBSTRING( expression FROM expression FOR expression )\n  SUBSTRING( expression FROM expression )
45 trim 함수의 형식이 잘못되었습니다.\n  TRIM ( [LEADING|TRAILING|BOTH] expression FROM expression )\n  TRIM ( [LEADING|TRAILING|BOTH] FROM expression )\n  TRIM ( expression FROM expression )\n  TRIM ( expression )
46 cast 함수의 형식이 잘못되었습니다.\n  CAST ( expression AS data_type )
47 add_months 함수는 두 인수가 필요합니다.
48 octet_length 함수는 하나의 인수가 필요합니다.
49 bit_length 함수는 하나의 인수가 필요합니다.
50 lower 함수는 하나의 인수가 필요합니다.
51 upper 함수는 하나의 인수가 필요합니다.
52 translate 함수는 세개의 인수가 필요합니다.
53 replace 함수는 둘이나, 세 개의 인수가 필요합니다.
54 to_number 함수의 형식이 잘못되었습니다.\n  TO_NUMBER ( expression , char_string )\n  TO_NUMBER ( expression )
55 스트링 결합 연산자는 '|' 이 아니라 '||' 입니다.
56 잘못된 형식의 alter 구문입니다.
57 잘못된 형식의 drop 구문입니다.
58 잘못된 형식의 create 구문입니다.
59 잘못된 형식의 관계연산자입니다.
60 equal 연산자는 '==' 이 아니라 '=' 입니다.
61 not equal 연산자는 '!=' 이 아니라 '<>' 입니다.
62 허용되지 않는 음수값입니다.
63 reference rule 이 중복되었습니다.
64 SYS_CONNECT_BY_PATH 함수는 두 개의 인수를 필요로 하며 두번째 인수는 문자열이어야 합니다.
65 %s는 올바른 unsigned integer가 아닙니다.
66 IF 함수는 세 개의 인수가 필요합니다.: 첫번째는 논리 표현식, 두번째와 세번째는 산술 표현식이거나 문자열 표현식이어야 합니다.
67 IFNULL 함수는 두 개의 인수가 필요하며 숫자 표현식이나 문자열 표현식이어야 합니다.
68 잘못된 형식의 isnull 함수입니다.\n  ISNULL ( expression )
69 잘못된 형식의 left 함수입니다.\n  LEFT ( str , len )
70 잘못된 형식의 right 함수입니다.\n  RIGHT ( str , len )
71 잘못된 형식의 mod 함수입니다.\n MOD( expression, expression )
72 잘못된 형식의 adddate 함수입니다.\n ADDDATE( expression, expression )
73 잘못된 형식의 date_add 함수입니다.\n DATE_ADD( expression, INTERVAL expression unit)
74 잘못된 형식의 subdate 함수입니다.\n SUBDATE( expression, expression )
75 잘못된 형식의 date_sub 함수입니다.\n DATE_SUB( expression, INTERVAL expression unit)
76 잘못된 형식의 user / system_user 함수입니다.\n USER() / SYSTEM_USER()
77 잘못된 형식의 timestamp 함수입니다.\n TIMESTAMP( expression ), TIMESTAMP( expression, expression )
78 잘못된 형식의 database 함수입니다.\n DATABASE()
79 잘못된 형식의 current_time 함수입니다.\n CURRENT_TIME()
80 잘못된 형식의 current_date 함수입니다.\n CURRENT_DATE()
81 잘못된 형식의 current_timestamp 함수입니다.\n CURRENT_TIMESTAMP()
82 잘못된 형식의 now 함수입니다.\n NOW()
83 잘못된 형식의 default 함수입니다.\n DEFAULT(column_name)
84 잘못된 형식의 date 함수입니다.\n DATE(expression)
85 잘못된 형식의 localtime 함수입니다.\n LOCALTIME()
86 잘못된 형식의 localtimestamp 함수입니다.\n LOCALTIMESTAMP()
87 잘못된 형식의 schema 함수입니다.\n SCHEMA()
88 잘못된 형식의 truncate 함수입니다.\n TRUNCATE( expression, expression )
89 잘못된 형식의 str_to_date 함수입니다.\n STR_TO_DATE( expression, string_literal )
90 잘못된 형식의 current_datetime 함수입니다.\n CURRENT_DATETIME()
91 missing the keyword GLOBAL

$set 8 MSGCAT_SET_PARSER_SEMANTIC
1 메모리가 부족합니다
2 함수 %s 은(는) 정의되어 있지 않습니다.
3 데이터베이스에서 ldb '%s' 을(를) 찾을 수 없습니다.
4 왼쪽 질의문의 컬럼 개수 %d와(과) 오른쪽 질의문의 \n컬럼 개수 %d이(가) 일치하지 않습니다.
5 '%s'는 '%s'와 union 호환성이 없습니다.
6 %s 은(는) 정의되지 않았습니다.
7 %s의 도메인은 가상 클래스가 될 수 없습니다.
8 %s의 도메인은 프락시 가상 클래스가 될 수 없습니다.
9 %s의 도메인은 클래스가 될 수 없습니다.
10 %s은(는) %s의 속성이 아닙니다.
11 %s은(는) 이 클래스에서 변경할 수 없습니다.\n %s로부터 상속되었습니다.
12 %s 클래스는 존재하지 않습니다. 
13 %s은(는) %s가 아닙니다.
14 %s은(는) %s의 메소드 또는 속성이 아닙니다.
15 %s은(는) 질의 명세를 가질 수 없습니다. 
16 %s은(는) 데이터베이스에서 정의 되지 않습니다.
17 %s은(는) %s의 슈퍼클래스가 아닙니다.
18 클래스 %s은(는) 비 클래스 %s로부터 상속됩니다. 
19 가상 클래스 %s은(는) 비 가상 클래스 %s로부터 상속됩니다. 
20 프락시 가상 클래스 %s는 비 프락시 가상 클래스 %s로부터 상속됩니다.
21 %s은(는) 이미 %s의 슈퍼 클래스입니다.
22 %s은(는) 그 자신의 슈퍼 클래스가 될 수 없습니다.
23 %s은(는) 이미 %s 의 서브클래스 입니다.
24 %s은(는) 단일 값이 아닙니다. aggregate 질의어 내에 나타난 속성은 "group by" 절 내에 나타나야 합니다.
25 컬럼 개수(%d) 와(과) into_names(%d) 개수가 다릅니다.
26 %s 클래스는 이미 존재 합니다.
27 '%2$s'의 슈퍼클래스 %s은(는) 존재하지 않습니다.
28 INHERIT 절 '%s'을(를) 위해서는 SUBCLASS 절이 필요합니다.
29 INHERIT 절 '%s'는 SUBCLASS 절 '%s' 내에 없는 클래스를 참조하고 있습니다.
30 클래스는 질의 명세를 가질 수 없습니다.
31 %s 은(는) 등록된 ldb가 아닙니다.
32 상속받은 프락시는 자체의 object_id 절을 가질 수 없습니다. 상속된 object_id 속성을 무시할 수 없습니다.
33 프락시 가상 클래스는 하나 이상의 질의 명세를 가져야 합니다.
34 속성 개수 %d 은(는) 질의 명세 내의 컬럼 개수 %d 와(과) 일치하지 않습니다.
35 %s 을(를) 위한 속성 이름이 없습니다.
36 속성 '%s' 은(는) 질의 명세의 컬럼 '%s' 와(과) 호환되지 않습니다.
37 %s는 클래스가 아닙니다.
38 가상클래스에서는 인덱스를 생성할 수 없습니다.
39 인덱스는 하나의 속성에 대해서 생성할 수 있습니다.
40 FROM 절 내 다중 테이블이 유효하지 않은 형태로 사용되었습니다.
41 시스템 에러 --  %s 에서 resolution 할 수 없습니다. 
42 derived table을 이용하여 삭제할 수 없습니다. 
43 사용자 %s 은(는) 데이터베이스에 정의되지 않았습니다.
44 Update 질의에서는 aggregation을 사용할 수 없습니다.
45 클래스 내에서 속성 이름은 유일해야 합니다. 속성 이름인 '%s' (이)가 클래스 '%s' 에서 두 번 이상 명세 되었습니다.
46 %s 에 대한 다중 할당이 있습니다.
47 sort spec에 사용된 숫자가 정수가 아닙니다.
48 sort spec의 %d 은(는) 범위를 벗어났습니다. 
49 order by item이 정수가 아닙니다.
50 sort spec %s 이(가) select 컬럼 내에 나타나지 않았습니다.
51 컬럼 %s에 대해 상반되는 소트 명령이 있습니다.
52 sort spec내 %s는 숫자, 이름 혹은 path expression이 아닙니다.
53 Insert expression은 오직 insert 문장에서만 사용될 수 있습니다.
54 속성 개수(%d)와 select 컬럼 개수(%d)가 다릅니다.
55 속성 개수(%d)와 values 절의 개수(%d)가 다릅니다.
56 데이터 타입 %s 에 데이터 오버플로우 발생.
57 속성 %s와 호환되지 않는 데이터 타입입니다.
58 %s\n 은(는) 단일 클래스에 대한 SELECT가 아닙니다.
59 `*'은 프락시 가상 클래스 질의 명세에 사용할 수 없습니다.
60 %s 은(는) 가상 클래스도 프락시 가상 클래스도 아닙니다.
61 하나 이상의 isolation 레벨 절이 있습니다.
62 하나 이상의 timeout 절이 있습니다.
63 isolation 레벨을 지정하지 않았습니다.
64 BETWEEN 연산자는 타입 %s,%s 그리고 %s 에서는 사용할 수 없습니다.
65 '%s' 연산자는 타입 %s 와 %s 에서는 사용할 수 없습니다.
66 Function은 인자 %s 이(가) 주어져야 합니다.
67 호환되지 않는 피 연산자 %s(%s).
68 Aggregate 함수는 반드시 하나의 인자 %s 을(를) 가져야 합니다.
69 0으로 나눌 수 없습니다.
70 타입을 %s 에서 %s 로 변환 시 오버플로우가 발생합니다.
71 타입 %s 을(를) %s 로 변환할 수 없습니다.
72 '%s'의 타입은 SET, MULTISET, 또는 SEQUENCE 이어야 합니다.
73 '%s'는 정확하게 하나의 set 원소 타입을 가져야 합니다.
74 %s 은(는) 하나 이상의 derived column 이름을 가지고 있습니다.
75 %s 은(는) derived column 이름을 포함하고 있지 않습니다.
76 %s 의 컬럼의 개수(%d)와 컬럼 이름의 개수(%d)가 일치하지 않습니다.
77 %s 내에 속성이 없습니다.
78 %s 내에 단일 테이블이 주어져야 합니다.
79 이름 %s 이 모호합니다.
80 derived column 이름 '%s' 은(는) 단순 클래스 명세에서는 허용되지 않습니다.
81 derived table '%s'은(는) correlation 이름을 가져야 합니다.
82 클래스 %s에 대한 select 권한이 없습니다. 
83 class instance %s을(를) derived table 이름으로 참조하는 것은 허용되지 않습니다.
84 Path correlation (%s)은 내부 path term 외부에 나타나고 있습니다.
85 %s 에 대한 참조가 모호합니다.
86 %s 의 클래스는 속성 %s를 갖고 있지 않습니다.
87 클래스들(%s) 모두가 속성 %s를 갖고 있지는 않습니다.
88 클래스(%s) 은(는) 속성 %s를 갖고 있지 않습니다.
89 %s는 %s 타입으로, 오브젝트 타입이 아닙니다.
90 Selector {%s} 은(는) 요구된 context (%s) 안에 \n명시된 클래스 명세를 resolve 하지 않습니다.
91 Selector {%s} 은(는) 클래스가 아닌 명세(%s)를 참조합니다.
92 Selector {%s} 은(는) 자기 자신을 정의하는 path expression을 근원으로 삼을 수 없습니다.
93 Selector {%s} 은(는) selector {%s}에 의해 순환 정의됩니다.
94 Selector {%s} 은(는) %s에서 재정의됩니다.
95 %s (도메인 오브젝트)는 속성 %s를 갖고 있지 않습니다.
96 EXCEPT 절 내의 %s 은(는) 서브클래스가 아닙니다.
97 ALL ... EXCEPT 리스트는 클래스 내 EVERYTHING 을 배제합니다.
98 '%s' is inconsistent with\nother use of path selector '%s' or of path root '%s'.
99 정의 되지 않은 인자입니다.
100 인자가 오브젝트가 아닙니다.
101 %s는 %s의 클래스 메소드나 속성이 아닙니다.
102 질의 명세는 into-절을 가질 수 없습니다.
103 프락시 질의 명세에는 aggregate 식, group-by 절, having 절 등을 사용할 수 없습니다.
104 프락시 질의 명세에는 select 리스트에 DISTINCT나 UNIQUE 키워드를 사용할 수 없습니다. 
105 프락시 질의 명세에는 단순 SELECT 문만 사용할 수 있습니다.
106 프락시 질의 명세는 로컬 데이터베이스의 한 클래스만 참조할 수 있습니다.
107 사용자 '%s'는 %s의 소유자가 아닙니다.
108 프락시 '%1$s'는 이미 ldb '%3$s'의 클래스 '%2$s'를 정의하고 있습니다.
109 CUBRID는 heterogeneous sets을 가지는 오브젝트를 지원하지 않습니다.
110 Where 절은 논리적 타입 식이어야 합니다.
111 Like escape 절은 문자 문자열 또는 호스트 변수이어야 합니다.
112 유효하지 않은 Precision (%d), scale (%d) 값입니다.
113 주어진 precision %1$d는 유효하지 않습니다; %2$d에서 %3$d사이의 값이어야 합니다.
114 지정한 precision (%d)이 너무 큽니다. 최대 precision은 %d 입니다.
115 메소드 %s 은(는) 리턴 타입을 가져야 합니다.
116 메소드에 주어지는 인자의 개수가 메소드에 정의된 개수와 다릅니다.
117 메소드를 호출하기 위해서는 대상이 지정되어야 합니다. 
118 메소드 %s 은(는) 지정된 대상에 대하여 정의되지 않았습니다.
119 인스턴스 메소드는 클래스 오브젝트에 대해 호출할 수 없습니다.
120 클래스 메소드는 인스턴스 오브젝트에 대해 호출할 수 없습니다.
121 클래스 메소드의 호출 대상은 클래스 오브젝트입니다.
122 메소드는 호출 대상으로 오브젝트가 필요합니다.
123 메소드 %s의 타입이 제대로 정의되어 있지 않습니다. 클래스 스키마의 메소드 정의를 확인하십시오.
124 시간 연산 시 언더플로우 발생.
125 날짜 연산 시 언더플로우 발생.
126 Assignment 절의 왼쪽이 잘못되어 있습니다.
127 set expression이 서브질의 내에 포함되어 있지 않으면 외부와 correlate된 \nset derived table에 대한 메소드를 호출할 수 없습니다.
128 공유 속성 '%s'에 해당하는 질의 명세 컬럼은 NULL 이나 NA 이어야 합니다.
129 뷰 정의시 애트리뷰트가 정의되지 않은 경우에는 질의 명세의 select 리스트에 NULL 컬럼이 포함될 수 없습니다.
130 set 내에 가상클래스 오브젝트를 사용할 수 없습니다.
131 문자열이 예상됩니다.
132 문장 또는 문자열이 예상됩니다.
133 프락시 object_id 속성 '%s'는 질의 명세의 컬럼으로 대응될 수 없습니다.
134 %s 제약 조건이 무시되었습니다.
135 현재 문맥에서는 제약 조건을 선언할 수 없습니다.
136 %s에서 타입 %s로의 변환은 제공되지 않습니다.
137 %s 은 유효한 비트 문자열이 아닙니다.
138 '%s' 연산자는 타입 %s에 대해 사용할 수 없습니다.
139 '%s' 연산자는 타입 %s, %s, 그리고 %s 에 대해 사용할 수 없습니다.
140 연산자 '%s'의 피연산자는 동적 호스트 변수로 사용할 수 없습니다.
141 generic 함수 %s에 너무 많은 인자가 주어졌습니다.\n오직 %d 개의 인자만이 허용됩니다.
142 Selector {%s} class '%s'는 '%s'의 서브클래스가 아닙니다.
143 '%s' 필드를 type %s로 부터 추출할 수 없습니다.
144 질의 명세에 ORDER BY 절이 포함될 수 없습니다.
145 case 문의 조건식은 논리 타입 식이어야 합니다.
146 식은 type %s 이어야 합니다.
147 serial '%s'는(은) 이미 존재합니다.
148 serial '%s'는(은) 정의되어 있지 않습니다.
149 증가 수치로 0을 지정할 수 없습니다.
150 최대 값(1.0e37) 초과
151 최소 값은 허용되지 않는 값입니다.
152 증가 수치는 허용되지 않는 값입니다.
153 최소 값이 허용치(-1.0e36)를 넘었습니다.
154 최대 값이 허용되지 않는 수치입니다.
155 serial 변경을 위해 옵션을 지정하십시오.
156 생성자나 DBA만이 대상 serial을 변경(Alter)할 수 있습니다.
157 serial 값은 최대 값이나 최소 값을 초과할 수 없습니다.
158 serial 내부 I/O 에러
159 인덱스 '%s'을(를) 찾을 수 없습니다.
160 인덱스 '%s'에 명시된 클래스 이름이 FROM 절에 명시되지 않았습니다.
161 인덱스 '%s'이(가) FROM 절의 두 개 이상의 클래스에 정의되어 있습니다.
162 잘못된 '%s 사용.\n%s 표현식은 속성이나 상관관계가 있는 부 질의와 같이 사용할 수 없습니다.
163 현재 버전은 ORDERBY_NUM()이 포함된 표현식을 select list에 사용할 수 없습니다.
164 조인 조건 절에 path expression '%s' 사용.
165 조인 조건 절의 %s 은(는) 정의되지 않았습니다.
166 현재 버전은 set derived table에 대한 오른쪽 외부 조인을 제한하고 있습니다.
167 다른 ldb에 대한 쿼리로 insert 할 수 없습니다.
168 EXISTS와 함께 쓰지 않는 부질의의 select list에는 한 개의 컬럼만을 사용할 수 있습니다.
169 Assignment 절의 오른쪽이 잘못되어 있습니다. 문맥상 질의문에 하나의 컬럼이 지정되어야 합니다.
170 조인 조건에는 부 질의를 사용할 수 없습니다.
171 잘못된 파티션 정의입니다.
172 파티션 컬럼이 지정되어야 합니다. 
173 파티션 컬럼은 1개만 지정할 수 있습니다.
174 지원되지 않는 파티션 컬럼 타입입니다.
175 중복된 파티션 정의 입니다. '%s'
176 상수의 타입이 일치하지 않습니다. '%s'
177 파티션의 크기가 잘못 지정되었습니다.
178 파티션이 적용되지 않은 클래스입니다. '%s'
179 이미 파티션이 적용된 클래스입니다. '%s'
180 잘못된 파티션 작업 요구입니다.
181 %s은(는) 이 클래스에서 변경할 수 없습니다.(파티션 기준 컬럼).
182 %s은(는) 활성 트리거로 인하여 파티션 작업을 할 수 없습니다.
183 %s은(는) 존재하지 않는 파티션입니다.
184 %s은(는) 파티션 타입이 일치 하지 않습니다.
185 파티션 정보에 오류가 있습니다.
186 파티션 추가는 기존 범위보다 큰 값으로 지정해야 합니다
187 데이터 소실 가능성이 있는 재구성은 허용하지 않습니다.
188 %s에 대한 파티션 범위 지정 오류 입니다.
189 클래스 속성에 auto increment 제약 조건을 정의할 수 없습니다.
190 가상 클래스 속성에 auto increment 제약 조건을 정의할 수 없습니다.
191 Auto increment 제약 조건을 가진 속성 '%s'에 사용할 수 없는 도메인입니다.
192 외래키 'ON CACHE OBJECT'절로 생성된 속성 '%s'에는 사용자가 직접 값을 할당할 수는 없습니다.
193 인덱스 키 리스트에 중복된 속성 이름이 허용되지 않습니다.  속성 이름인 '%s' (이)가 두 번 이상 나열 되었습니다.
194 함수 %s 은(는) 정의되어 있지 않거나, 파라미터 갯수가 틀립니다.
195 '%s' can only be used in hierarchical queries. Specify a CONNECT BY clause.
196 '%s' is not allowed here.
197 CONNECT_BY_ISCYCLE은 CONNECT BY NOCYCLE 절이 명시된 질의문에서만 사용할 수 있습니다.
198 사용되는 테이블이 없습니다.
199 ORDER BY NULL은 GROUP BY 절과 함께 사용됩니다.
200 CACHE에는 한 사이클 값(%s)보다 작은 값을 지정해야 합니다.
201 '%s'은(는) LIMIT절이 포함된 질의문에서 사용할 수 없습니다.
202 WITH ROLLUP은 GROUP BY 절과 함께 사용됩니다.
203 컬럼 이름이 DEFAULT 함수의 인자로 지정되어야 합니다. path expression은 현재 버전에서 지원되지 않습니다.
204 중복된 테이블 옵션(%s)입니다.
205 REUSE_OID 옵션이 지정된 클래스 '%s'를 참조할 수 없습니다. 참조 불가능한 클래스는 애트리뷰트의 도메인이 될 수 없으며, 인스턴스의 OID를 조회할 수 없습니다.
206 'serial %s' 옵션이 중복되었습니다.
207 ORDER BY 절의 컬럼 '%s' (이)가 모호합니다.
208 애트리뷰트 '%s'에 대한 DEFAULT 값이 정의되지 않았습니다.
209 SELECT DISTINCT가 지정된 경우에는 ORDER BY 항목이 SELECT 목록에 나타나야 합니다.
210 질의 명세의 컬럼 정의에는 호스트 변수를 사용할 수 없습니다.
211 Class '%s' is stored on node '%s'. The node cannot be found in cluster. 
212 Cannot find out the connected node.
213 Cannot find out node '%s' in cluster.
214 The node count can't be larger than hash count.
215 Global partitioned table by range or list is not supported. 
216 Global keyword is mandatory when create, alter, rename or drop global entity.
217 Global keyword is not allowed when create, alter, rename or drop local entity.
218 Rename or delete global entity and local entity together are not allowed.
219 Global view is not supported.
220 Global non-partitioned table only can be specified one node.
221 Cache option is mandatory for global serial and cache size should large than 0.
222 Global table join is not supported.
223 Global table subquery is not supported.
224 Object oriented features are not supported in global table. such as: class attribute, class method, inherit and so on.
225 Alter partition of Global table is not supported.
226 Foreign key is not supported for global table.
227 CREATE TABLE ... LIKE or CREATE TABLE ... AS SELECT is not supported for global table.
228 The columns which will add primary key or unique constraints must include partition key column in global partition table.
229 GROUP BY ... HAVING clause is not supported in global table query.
230 ON DUPLICATE KEY UPDATE Statement is not supported when inserting data into global table.
231 Update partition key of global partition table is not supported.
232 REPLACE statement is not suppoprted for global table.
233 TRUNCATE statement is not supported for global table.
234 CUBRID Cluster features are not supported in standalone mode.
235 Global trigger is not supported.
236 Local table can not use global table.
237 START WITH ... CONNECT BY Clause is not supported for global table.
238 AUTO INCREMENT is not supported for global table.
239 UPDATE with subquery is not suported for global table.
240 DELETE with subquery is not suported for global table.

$set 9 MSGCAT_SET_PARSER_RUNTIME
1 가상 메모리 없음: %d 바이트를 할당할 수 없습니다.
2 트랜잭션 isolation 레벨은 1, 2, 3, 4, 5, 6 중에서 지정되어야 합니다.
3 타임아웃 값은 -1, 0 또는 >0 이어야 합니다.
4 Isolation 레벨은 다음과 같습니다\n
5          READ COMMITTED SCHEMA, READ UNCOMMITTED INSTANCES.\n
6          READ COMMITTED SCHEMA, READ COMMITTED INSTANCES.\n
7          REPEATABLE READ SCHEMA, READ UNCOMMITTED INSTANCES.\n
8          REPEATABLE READ SCHEMA, READ COMMITTED INSTANCES.\n
9          REPEATABLE READ SCHEMA, REPEATABLE READ INSTANCES.\n
10 db_query_execute_oid 를 이용하여 non-updatable 질의를 수행할 수 없습니다.
11 트랜잭션이 락 대기 중에 타임아웃되었습니다.
12 %ld 번째 호스트 변수를 액세스하려고 하지만, 단지 %ld 개의 호스트 변수만이 주어져 있습니다. 
13 지원되지 않는 변환입니다. 
14 내부 에러: 정의되지 않은 변환입니다.
15 '%s' 은(는) 결과가 없습니다.
16 '%s' 은(는) 하나 이상의 결과를 가져옵니다.
17 인터프리터 변수 %s 은(는) 정의되지 않았습니다.
18 '%s'를 evaluate할 수 없습니다.
19 알 수 없는 변수 %s 입니다.
20 알 수 없는 공유 속성 %s 입니다.
21 '%s' 은(는) 하나 이상의 컬럼을 가져옵니다.
22 aggregate function을 잘못 사용했거나 중첩 사용하였습니다. 
23 Functions %s 은(는)  정의되지 않았습니다. 
24 문맥상 질의문에 하나의 컬럼이 지정되어야 합니다.\n(%s) 
25 너무 많은 값들이 명시되어 있습니다.
26 Virtual assignment target (%s) 은(는) 반전 시킬 수 없습니다.
27 질의 명세에 지정된 컬럼이 클래스 %s의 속성보다 많습니다.
28 질의 명세에 지정된 컬럼보다 클래스 %s의 속성이 많습니다.
29 현재 버전은 aggregate 질의 명세 없는 가상클래스들에 대한 aggregation을 제한하고 있습니다.
30 현재 버전은 union 질의 명세 없는 가상클래스들에 대한 aggregation을 제한하고 있습니다. 
31 composition hierarchy 상의 가상 클래스(%s)는 update 가능해야 합니다.\n 실제 클래스 %s에 대해 update할 수 없습니다.
32 (사용되지 않음)
33 path expression '%s' 이(가) 잘못되어 있습니다.
34 path expression '%s' crosses db boundary to %s, with vclass %s.
35 path expression '%s' crosses db boundary from %s, to class %s.
36 %s 은(는) %s 에 대해 권한이 없습니다.
37 %s 에 대해 Select 권한이 없습니다.
38 가상 클래스 %s 은(는) update 가능하지 않습니다.
39 %s 은(는) 프락시 가상 클래스가 아닙니다.
40 프락시 가상 클래스의 질의 명세에는 join을 사용할 수 없습니다.
41 %s 는(은) 오브젝트 id set을 갖고 있지 않습니다.
42 composition hierarchy에서 여러 개의 object_id 필드를 가진 클래스들(%s)은 지원되지 않습니다. 
43 %2$s의 오브젝트 속성 %1$s은(는) ldb %3$s의 가상 클래스가 아닙니다.
44 질의 명세 타입이 속성 %s 와(과) 호환되지 않습니다.
45 질의 명세 %s는 그 자신을 포함한 순환 reference를 갖고 있습니다.
46 Evaluate할 식이 주어지지 않았습니다.
47 가상 클래스 %s에 정의된 실제 클래스를 찾을 수 없습니다.
48 ldb %2$s에서 %1$s 수행\n 리턴: %3$s
49 %s 값을 속성 '%s'에 할당. 리턴: %s
50 ldb 이름은 %s 에서 null이 될 수 없습니다.
51 호스트에서 ldb 이름은 %s 에서 null이 될 수 없습니다.
53 호스트 이름은 %s 내에서 null이 될 수 없습니다.
54 사용자 이름은 %s 내에서 null이 될 수 없습니다.
55 사용자 패스워드는 %s 내에서 null이 될 수 없습니다.
56 Insert는 빈 문장으로 바꾸어 집니다.
57 Update는 빈 문장으로 바꾸어 집니다.
58 Delete는 빈 문장으로 바꾸어 집니다.
59 INGRES는 1582년 1월 1일 이전 날짜(%s)를 지원하지 못합니다.
60 질의를 생성하는 동안 시스템 자원이 고갈되었습니다.
61 결과가 없는 질의입니다. 따라서, 변수 '%s' 은(는) 지정되지 않았습니다.
62 with LOCAL check option은 지원되지 않습니다.
63 뷰 %s에 대한 check option 예외 상황
64 유효하지 않은 날짜: '%s'
65 유효하지 않은 시간: '%s'
66 유효하지 않은 utime: '%s'
67 프락시의 질의 명세에서 서브질의를 사용할 수 없습니다.
68 ldb 함수의 인자가 '%s'의 ldb와 호환되지 않습니다.
69 유효하지 않은 numeric: '%s'
70 외부 조인 쿼리 최적화 실패.
71         SERIALIZABLE.\n
72 Vclass %s는 updatable vclass가 아닙니다. updatable vclass에 대해서만 VID를 select할 수 있습니다.
73 파티션 작업 오류입니다.
74 해당되는 파티션이 존재하지 않습니다.
75 허용되지 않는 파티션 접근입니다: '%s'
76 serial '%s'는(은) 정의되어 있지 않습니다.
77 소유자나 DBA만이 대상 시리얼의 정의를 변경(Alter)할 수 있습니다. 
78 Auto increment 제약 조건으로 생성된 시리얼 객체는 임의로 변경할 수 없습니다. 
79 유효하지 않은 Isolation 수준: %s 스키마, %s 객체.

$set 11 MSGCAT_SET_AUTHORIZATION
1 *** 잘못된 캐시 ***
2   클래스 %s 
3 %s 로부터 : 
4 사용자 %s 을(를) 위한 권한\n
5 미정의된 사용자에 대한 권한\n
6 사용자 : %s\n
7 	       id : %d\n
8          멤버들 : 
9          그룹들 : 
10 사용자 %s\n
11 현재 사용자는 : %s\n
12 루트 권한 오브젝트 :\n
13   사용자 : 
14 *** 사용자 "%s" 을(를) 위하여 모든 권한을 부여할 수 없습니다*** \n
15 권한\n
16 direct_groups :

$set 12 MSGCAT_SET_HELP
1 루트 클래스
2 %s %s\n
3 슈퍼클래스 :\n
4 서브클래스 :\n
5 속성 :\n
6 메소드 : \n
7 클래스 속성 :\n
8 클래스 메소드 : \n
9 Conflict resolutions:\n
10 메소드 파일 :\n
11 질의어 명세 :\n
12 %s의 오브젝트 :\n
13 \n내용 :\n
14 \n구조 :\n
15 \n예제 :\n
16 메타 클래스 명
17 클래스 명
18 가상클래스(VClass) 명
$  Don't delete the space at the end of the next message
19 ldb 상의 가상클래스 
20 GENERAL

$set 13 MSGCAT_SET_TRIGGER
1 TRACE: 트리거 '%s'의 조건 검사
2 TRACE: 트리거 '%s'의 액션 수행

$set 14 MSGCAT_SET_LOCK
1 \n
2 스레드(index %3d) (트랜잭션 (index %3d, %s, %s@%s|%d))가 중단되었습니다.\n
3 스레드(index %3d) (트랜잭션 (index %3d, %s, %s@%s|%d))이 재개되었습니다.\n
4 트랜잭션 %3d 이(가) %s 락(오브젝트 %d|%d|%d 에 대해)을 획득\n
5 트랜잭션 %3d 이(가) %s 락(페이지 %d|%d 에 대해)을 획득.\n
6 트랜잭션 %3d 이(가) %s 락(오브젝트 %d|%d|%d 에 대한)으로 변환.\n
7 트랜잭션 %3d 이(가) %s 락(페이지 %d|%d 에 대한)을 변환.\n
8 트랜잭션 %3d 이(가) %s 락(오브젝트 %d|%d%d 에 대해) 대기.\n
9 트랜잭션 %3d 이(가) %s 락(페이지 %d|%d 에 대해) 대기.\n
10 트랜잭션 %3d 이(가) %s 락(오브젝트 %d|%d|%d 에 대한)을 해제.\n
11 트랜잭션 %3d 이(가) %s 락(페이지 %d|%d 에 대한)을 해제.\n
12 트랜잭션 %3d 이(가) %s 락(오브젝트 %d|%d|%d 에 대한)으로 하향 변경.\n
13 트랜잭션 %3d 이(가) %s 락(페이지 %d|%d 에 대한)으로 하향 변경.\n
14 OID = %2d|%6d|%4d\n
15 락 대상: Root class.\n
16 락 대상: Class = %s.\n
17 락 대상: Instance of class (%2d|%6d|%4d) = %s.\n
18 락 대상: Unknown.\n
19 Total mode of holders = %8s, Total mode of waiters = %8s.\n
20 Num holders=%3d, Num blocked-holders=%3d, Num waiters=%3d\n
21 LOCK HOLDERS:\n
22 BLOCKED LOCK HOLDERS:\n
23 LOCK WAITERS:\n
24 NON_2PL_RELEASED:\n
25 %4sTran_index = %3d, Granted_mode =%8s, Count = %3d\n
26 %4sTran_index = %3d, Granted_mode =%8s, Count = %3d, Nsubgranules = %2d\n
27 %4sTran_index = %3d, Granted_mode =%8s, Count = %3d\n\t%13s Blocked_mode = %8s\n\t%17s Start_waiting_at = %-30s\n\t%17s Wait_for_nsecs = %d\n
28 %4sTran_index = %3d, Granted_mode =%8s, Count = %3d, Nsubgranules = %2d\n\t%13s Blocked_mode =%8s\n\t%13s Start_waiting_at = %-30s\n\t%13s Wait_for_nsecs = %d\n
29 %4sTran_index = %3d, Blocked_mode =%8s \n\t%13s Start_waiting_at = %-30s \n\t%13s Wait_for_nsecs = %d\n
30 %4sTran_index = %3d, Non_2_phase_lock =%8s\n
31 VPID (volid|pageid) = %3d|%6d.\n
32 *** 락 테이블 덤프  ***\n 락 상승    = %d, Run Deadlock interval = %d\n
33 트랜잭션 (인덱스 %2d, %s, %s@%s|%d)\n
34 격리도 %s\n
35 수행상태 %s\n
36 타임아웃 주기 %d\n
37 일방적으로 종료된 트랜잭션 인덱스 리스트:\n
38 %d ,
39 타임아웃 된 트랜잭션 인덱스 리스트:\n
40 %d ,
41 Solving the deadlock by selecting a transaction and a function \n to break the deadlock: %d %s
42 , %d %s

$set 15 MSGCAT_SET_IO
1 \n*************************************************************************\n
2 Backup = %s is needed. \n It must be mounted/loaded to continue.\n Type 1 to continue after the backup is mounted/loaded.\n Type 0 to quit.\n
3 \n\n*** BACKUP HEADER INFORMATION ***\n\n
4 Backup magic file identification %s,\n
5           Release: %s\n\
     Disk Version: %g\n
6     Database Name: %s\n\
 DB Creation Time: %s\
         Pagesize: %d\n
7      Backup Level: %d (%s)\n\
        Start_lsa: %d|%d\n\
         Last_lsa: %d|%d\n
8       Backup Time: %s\
  Backup Unit Num: %d\n
9  Database Volume name: %s\n\
   Volume Identifier: %d, Size: %ld bytes (%d pages)\n
10    Database Name: %s\n\
     Volume Name: %s\n\
        Unit Num: %d\n\
    Backup Level: %d (%s)\n\
다음 옵션 중 하나를 선택하시오:\n
11 입력\n \
  -  %d: 종료\n \
  -  %d: 볼륨 마운트 후 계속 수행\n \
  -  %d: 볼륨 디렉터리나 디바이스 변경 후 계속 수행\n
12 백업 볼륨을 위한 새로운 디렉터리나 디바이스를 입력하시오\n
13 입력 에러, %d 와 %d 사이의 값을 선택하시오\n
14 ** 경고 ** 잘못된 백업 볼륨\n
15 백업 볼륨 %s은(는) 다른 백업 레벨로 작성된 것입니다.\n   (레벨: %d, 예상 레벨: %d).\n\n
16 백업 볼륨 %s은(는) 잘못된 page 또는 magic identifier를 가지고 있습니다.\n\n
17 백업 볼륨 %s은(는) 다른 데이터베이스를 백업한 것입니다.\n   (이름: %s, 예상: %s).\n\n
18 백업 볼륨 %s의 순서가 올바르지 않습니다.\n  (Unit Num: %d, 예상: %d).\n\n
19 백업 볼륨 %s의 timestamp가 올바르지 않습니다.\n   (Timestamp: %s, 예상: %s).\n\n
20 Backup volume information file error, line %d.\n
21 Backup Volume Label: Level: %d, Unit: %d, Database %s, Backup Time: %s\n
22      Previous Backup level: %d Time: %s (start_lsa was %d|%d)\n
23 데이터베이스 복구를 위해서 다음의 백업 볼륨이 필요합니다:\n\n
24 백업 장치의 여유 공간이 없습니다. 계속 진행하기 위해서 새로운 백업 장치가 필요합니다:\n\n
25 이전 백업 볼륨 이름: %s\n
26      다음 백업 볼륨 이름: %s\n
27   Backup Pagesize: %d\n
28        Zip Method: %d (%s)\n\
        Zip Level: %d (%s)\n
29 Include Active Log: %s\n

$set 16 MSGCAT_SET_LOG
1 \n*************************************************************************\n
2 정상 진행을 위해 아카이브 로그 %s \n이(가) 필요합니다. \n \
  Type\n \
  -  0: 종료\n \
  -  1: 아카이브 로그 없이 진행 (Partial recovery)\n \
  -  2: 아카이브 로그 마운트/로드 후 진행\n \
  -  3: 아카이브 로그 위치/이름 변경 후 진행\n 
3 데이터베이스 복구 작업을 위해 백업 정보 파일 %s\n이(가) 필요합니다. \n \
  Type\n \
  -  0: 종료\n \
  -  1: 파일 마운트/로드 후 진행\n \
  -  2: 파일 위치/이름 변경 후 진행\n 
4 새로운 위치/이름을 입력하시오.\n
5 COMMENT: %s for database %s\n
6 COMMENT: 아카이브 로그 %s는 media crash가 발생하지 않는 한 필요하지 않습니다. \n
7 COMMENT: 아카이브 로그 %s 부터 %s 까지는 media crash가 발생하지 않는 한 필요하지 않습니다. \n
8 COMMENT: from renamed database = %s\n
9 ARCHIVE: %d %s %d %d\n
10 ARCHIVE:
11 REMOVE: %d %s - %d %s . REASON: %s\n
12 ACTIVE: %s %d pages\n
13  Finish commit of tran_index %d with tranid = %d,\n just before LSA= %d|%d and at %s
14  Finish abort of tran_index %d with tranid = %d,\n just before LSA= %d|%d and at %s
15  Incomplete Media Recovery is in effect. The database will be \n \
 recovered up to LSA point address of %d|%d. Last commit/abort \n \
 point time is approximately at %s \n \
 The database has lost all information of transactions committed \n \
 after this time.\n
16 불완전한 복구로 인하여 로그가 reset되었습니다.
17 데이터베이스가 백업되었습니다.
18 Media crash is not important for the application.
19 %s 디렉터리에 이전 백업 볼륨이 존재하는 것 같습니다.\n\
해당 데이터베이스의 필요 없는 현재 백업 레벨을 포함한 상위 백업 볼륨들은 삭제됩니다.\n
20 계속 진행하려면 'y'를 중지하려면 아무 키나 누르시오.\n
21 사용자에 의해 백업이 중단되었습니다.\n
22 DELETE POSTPONED: Archives %d %s to \n \
        %d %s \n \
        are no longer needed unless a restore from current backup occurs.\n
23 A newer backup has released archives previously marked DELETE POSTPONED.\n
24 COMMENT: Log archive %s is not DELETE POSTPONED any longer due to more recent\n \
     backup and therefore is not needed unless a database media crash occurs.\n
25 COMMENT: Log archives from %s to %s are not DELETE POSTPONED any longer due to\n \
   more recent backup and therefore are not needed unless a database media\n \
   crash occurs.\n
26 데이터베이스를 복구하는 도중에 에러가 발생하였습니다\n\
     Backup Volume: %s\n\
          Unit Num: %d\n\
   Database Volume: %s\n\
    Database Volid: %d\n\
** 경고: 에러 없이 데이터베이스가 복구되기 전까지는 데이터베이스를 사용하지 마시오. 
27 입력 오류, %d와 %d 사이의 값을 선택하시오.\n
28 복구 시점(%s)은 반드시 백업 시점(%s) 이후로 지정해야 합니다. \n
29 COMMENT: 로그 페이지 %d 이전까지만 포함하는 아카이브 로그 %s 는 HA 유틸리티에서 더 이상 사용되지 않습니다.
30 아카이브 로그의 개수가 허용 최대치를 초과했습니다.
